/**
 * Performance Chart Visualization Component
 * Real-time performance graphs and charts for monitoring data
 */

export interface ChartDataPoint {\n  timestamp: number;\n  value: number;\n  label?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface ChartSeries {\n  name: string;\n  data: ChartDataPoint[];\n  color: string;\n  type: 'line' | 'area' | 'bar' | 'scatter';\n  yAxis?: 'left' | 'right';\n}\n\nexport interface ChartOptions {\n  title: string;\n  width: number;\n  height: number;\n  timeRange: number; // milliseconds\n  refreshInterval: number;\n  yAxis: {\n    left?: {\n      label: string;\n      min?: number;\n      max?: number;\n      unit?: string;\n    };\n    right?: {\n      label: string;\n      min?: number;\n      max?: number;\n      unit?: string;\n    };\n  };\n  xAxis: {\n    label: string;\n    format: 'time' | 'number' | 'category';\n  };\n  legend: {\n    position: 'top' | 'bottom' | 'left' | 'right' | 'none';\n    columns?: number;\n  };\n  grid: {\n    x: boolean;\n    y: boolean;\n  };\n  zoom: {\n    enabled: boolean;\n    type: 'x' | 'y' | 'xy';\n  };\n  tooltip: {\n    enabled: boolean;\n    format?: (point: ChartDataPoint, series: ChartSeries) => string;\n  };\n  thresholds?: Array<{\n    value: number;\n    color: string;\n    label: string;\n    yAxis?: 'left' | 'right';\n  }>;\n}\n\nexport interface ChartState {\n  series: ChartSeries[];\n  isAnimating: boolean;\n  selectedRange: {\n    start: number;\n    end: number;\n  } | null;\n  hoveredPoint: {\n    seriesIndex: number;\n    pointIndex: number;\n  } | null;\n}\n\nexport class PerformanceChart {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private animationId?: number;\n  private lastUpdate: number = 0;\n  private state: ChartState;\n  private observers: Array<(event: any) => void> = [];\n  \n  // Chart dimensions and layout\n  private margins = { top: 40, right: 60, bottom: 60, left: 60 };\n  private plotArea = { x: 0, y: 0, width: 0, height: 0 };\n  \n  // Colors and styling\n  private colors = {\n    background: '#1a1a1a',\n    gridLines: '#333333',\n    text: '#ffffff',\n    textSecondary: '#cccccc',\n    accent: '#00ff88',\n    warning: '#ffaa00',\n    critical: '#ff4444',\n    series: [\n      '#00ff88', '#0088ff', '#ff8800', '#ff0088',\n      '#88ff00', '#8800ff', '#ffff00', '#00ffff'\n    ]\n  };\n\n  constructor(\n    private container: HTMLElement | string,\n    private options: ChartOptions\n  ) {\n    this.initializeCanvas();\n    this.setupEventListeners();\n    this.state = {\n      series: [],\n      isAnimating: false,\n      selectedRange: null,\n      hoveredPoint: null\n    };\n    \n    this.calculateLayout();\n    this.startRenderLoop();\n  }\n\n  private initializeCanvas(): void {\n    // Create canvas element\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.options.width * window.devicePixelRatio;\n    this.canvas.height = this.options.height * window.devicePixelRatio;\n    this.canvas.style.width = `${this.options.width}px`;\n    this.canvas.style.height = `${this.options.height}px`;\n    \n    // Get container element\n    const container = typeof this.container === 'string' \n      ? document.querySelector(this.container)\n      : this.container;\n    \n    if (!container) {\n      throw new Error('Chart container not found');\n    }\n    \n    container.appendChild(this.canvas);\n    \n    // Get rendering context\n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Unable to get canvas rendering context');\n    }\n    \n    this.ctx = ctx;\n    this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\n    \n    // Set default font\n    this.ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';\n  }\n\n  private setupEventListeners(): void {\n    // Mouse events for interactions\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('click', this.handleClick.bind(this));\n    this.canvas.addEventListener('wheel', this.handleWheel.bind(this));\n    \n    // Resize handling\n    window.addEventListener('resize', this.handleResize.bind(this));\n  }\n\n  private calculateLayout(): void {\n    // Calculate plot area dimensions\n    this.plotArea = {\n      x: this.margins.left,\n      y: this.margins.top,\n      width: this.options.width - this.margins.left - this.margins.right,\n      height: this.options.height - this.margins.top - this.margins.bottom\n    };\n  }\n\n  private startRenderLoop(): void {\n    const render = (timestamp: number) => {\n      if (timestamp - this.lastUpdate >= (1000 / 60)) { // 60 FPS max\n        this.render();\n        this.lastUpdate = timestamp;\n      }\n      \n      this.animationId = requestAnimationFrame(render);\n    };\n    \n    this.animationId = requestAnimationFrame(render);\n  }\n\n  // Public API\n  public addSeries(series: ChartSeries): void {\n    // Assign color if not provided\n    if (!series.color) {\n      series.color = this.colors.series[this.state.series.length % this.colors.series.length];\n    }\n    \n    this.state.series.push(series);\n    this.notifyObservers('series_added', { series });\n  }\n\n  public updateSeries(name: string, data: ChartDataPoint[]): void {\n    const series = this.state.series.find(s => s.name === name);\n    if (series) {\n      // Keep only data within time range\n      const cutoff = Date.now() - this.options.timeRange;\n      series.data = [...data.filter(point => point.timestamp >= cutoff)];\n      \n      this.notifyObservers('series_updated', { name, data });\n    }\n  }\n\n  public removeSeries(name: string): void {\n    const index = this.state.series.findIndex(s => s.name === name);\n    if (index !== -1) {\n      this.state.series.splice(index, 1);\n      this.notifyObservers('series_removed', { name });\n    }\n  }\n\n  public addDataPoint(seriesName: string, point: ChartDataPoint): void {\n    const series = this.state.series.find(s => s.name === seriesName);\n    if (series) {\n      series.data.push(point);\n      \n      // Remove old data points outside time range\n      const cutoff = Date.now() - this.options.timeRange;\n      series.data = series.data.filter(p => p.timestamp >= cutoff);\n      \n      this.notifyObservers('data_point_added', { seriesName, point });\n    }\n  }\n\n  public setTimeRange(range: number): void {\n    this.options.timeRange = range;\n    \n    // Filter existing data\n    const cutoff = Date.now() - range;\n    this.state.series.forEach(series => {\n      series.data = series.data.filter(point => point.timestamp >= cutoff);\n    });\n    \n    this.notifyObservers('time_range_changed', { range });\n  }\n\n  public zoomToRange(start: number, end: number): void {\n    this.state.selectedRange = { start, end };\n    this.notifyObservers('zoom_changed', { start, end });\n  }\n\n  public resetZoom(): void {\n    this.state.selectedRange = null;\n    this.notifyObservers('zoom_reset', {});\n  }\n\n  // Rendering methods\n  private render(): void {\n    // Clear canvas\n    this.ctx.fillStyle = this.colors.background;\n    this.ctx.fillRect(0, 0, this.options.width, this.options.height);\n    \n    // Draw components\n    this.drawGrid();\n    this.drawAxes();\n    this.drawThresholds();\n    this.drawSeries();\n    this.drawLegend();\n    this.drawTooltip();\n    this.drawTitle();\n  }\n\n  private drawGrid(): void {\n    if (!this.options.grid.x && !this.options.grid.y) return;\n    \n    this.ctx.strokeStyle = this.colors.gridLines;\n    this.ctx.lineWidth = 1;\n    this.ctx.setLineDash([2, 4]);\n    \n    const { timeExtent, valueExtent } = this.getDataExtents();\n    \n    // Vertical grid lines (time)\n    if (this.options.grid.x && timeExtent) {\n      const timeSteps = this.calculateTimeSteps(timeExtent.min, timeExtent.max);\n      \n      timeSteps.forEach(time => {\n        const x = this.timeToX(time);\n        \n        this.ctx.beginPath();\n        this.ctx.moveTo(x, this.plotArea.y);\n        this.ctx.lineTo(x, this.plotArea.y + this.plotArea.height);\n        this.ctx.stroke();\n      });\n    }\n    \n    // Horizontal grid lines (values)\n    if (this.options.grid.y && valueExtent.left) {\n      const valueSteps = this.calculateValueSteps(valueExtent.left.min, valueExtent.left.max);\n      \n      valueSteps.forEach(value => {\n        const y = this.valueToY(value, 'left');\n        \n        this.ctx.beginPath();\n        this.ctx.moveTo(this.plotArea.x, y);\n        this.ctx.lineTo(this.plotArea.x + this.plotArea.width, y);\n        this.ctx.stroke();\n      });\n    }\n    \n    this.ctx.setLineDash([]);\n  }\n\n  private drawAxes(): void {\n    this.ctx.strokeStyle = this.colors.text;\n    this.ctx.fillStyle = this.colors.text;\n    this.ctx.lineWidth = 1;\n    this.ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';\n    \n    const { timeExtent, valueExtent } = this.getDataExtents();\n    \n    // X-axis (time)\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.plotArea.x, this.plotArea.y + this.plotArea.height);\n    this.ctx.lineTo(this.plotArea.x + this.plotArea.width, this.plotArea.y + this.plotArea.height);\n    this.ctx.stroke();\n    \n    // X-axis labels\n    if (timeExtent) {\n      const timeSteps = this.calculateTimeSteps(timeExtent.min, timeExtent.max);\n      \n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'top';\n      \n      timeSteps.forEach(time => {\n        const x = this.timeToX(time);\n        const label = this.formatTime(time);\n        \n        this.ctx.fillText(label, x, this.plotArea.y + this.plotArea.height + 8);\n      });\n    }\n    \n    // X-axis title\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'bottom';\n    this.ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';\n    this.ctx.fillText(\n      this.options.xAxis.label,\n      this.plotArea.x + this.plotArea.width / 2,\n      this.options.height - 10\n    );\n    \n    // Left Y-axis\n    if (this.options.yAxis.left && valueExtent.left) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.plotArea.x, this.plotArea.y);\n      this.ctx.lineTo(this.plotArea.x, this.plotArea.y + this.plotArea.height);\n      this.ctx.stroke();\n      \n      // Left Y-axis labels\n      const valueSteps = this.calculateValueSteps(valueExtent.left.min, valueExtent.left.max);\n      \n      this.ctx.textAlign = 'right';\n      this.ctx.textBaseline = 'middle';\n      this.ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';\n      \n      valueSteps.forEach(value => {\n        const y = this.valueToY(value, 'left');\n        const label = this.formatValue(value, this.options.yAxis.left?.unit);\n        \n        this.ctx.fillText(label, this.plotArea.x - 8, y);\n      });\n      \n      // Left Y-axis title\n      this.ctx.save();\n      this.ctx.translate(15, this.plotArea.y + this.plotArea.height / 2);\n      this.ctx.rotate(-Math.PI / 2);\n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'bottom';\n      this.ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';\n      this.ctx.fillText(this.options.yAxis.left.label, 0, 0);\n      this.ctx.restore();\n    }\n    \n    // Right Y-axis\n    if (this.options.yAxis.right && valueExtent.right) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(this.plotArea.x + this.plotArea.width, this.plotArea.y);\n      this.ctx.lineTo(this.plotArea.x + this.plotArea.width, this.plotArea.y + this.plotArea.height);\n      this.ctx.stroke();\n      \n      // Right Y-axis labels\n      const valueSteps = this.calculateValueSteps(valueExtent.right.min, valueExtent.right.max);\n      \n      this.ctx.textAlign = 'left';\n      this.ctx.textBaseline = 'middle';\n      this.ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';\n      \n      valueSteps.forEach(value => {\n        const y = this.valueToY(value, 'right');\n        const label = this.formatValue(value, this.options.yAxis.right?.unit);\n        \n        this.ctx.fillText(label, this.plotArea.x + this.plotArea.width + 8, y);\n      });\n      \n      // Right Y-axis title\n      this.ctx.save();\n      this.ctx.translate(this.options.width - 15, this.plotArea.y + this.plotArea.height / 2);\n      this.ctx.rotate(Math.PI / 2);\n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'bottom';\n      this.ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';\n      this.ctx.fillText(this.options.yAxis.right.label, 0, 0);\n      this.ctx.restore();\n    }\n  }\n\n  private drawThresholds(): void {\n    if (!this.options.thresholds) return;\n    \n    this.options.thresholds.forEach(threshold => {\n      const yAxis = threshold.yAxis || 'left';\n      const y = this.valueToY(threshold.value, yAxis);\n      \n      // Draw threshold line\n      this.ctx.strokeStyle = threshold.color;\n      this.ctx.lineWidth = 2;\n      this.ctx.setLineDash([8, 4]);\n      \n      this.ctx.beginPath();\n      this.ctx.moveTo(this.plotArea.x, y);\n      this.ctx.lineTo(this.plotArea.x + this.plotArea.width, y);\n      this.ctx.stroke();\n      \n      // Draw threshold label\n      this.ctx.fillStyle = threshold.color;\n      this.ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';\n      this.ctx.textAlign = 'left';\n      this.ctx.textBaseline = 'bottom';\n      \n      this.ctx.fillText(\n        threshold.label,\n        this.plotArea.x + 5,\n        y - 2\n      );\n    });\n    \n    this.ctx.setLineDash([]);\n  }\n\n  private drawSeries(): void {\n    this.state.series.forEach((series, index) => {\n      if (series.data.length === 0) return;\n      \n      this.ctx.strokeStyle = series.color;\n      this.ctx.fillStyle = series.color;\n      this.ctx.lineWidth = 2;\n      \n      const yAxis = series.yAxis || 'left';\n      \n      switch (series.type) {\n        case 'line':\n          this.drawLineSeries(series, yAxis);\n          break;\n        case 'area':\n          this.drawAreaSeries(series, yAxis);\n          break;\n        case 'bar':\n          this.drawBarSeries(series, yAxis);\n          break;\n        case 'scatter':\n          this.drawScatterSeries(series, yAxis);\n          break;\n      }\n    });\n  }\n\n  private drawLineSeries(series: ChartSeries, yAxis: 'left' | 'right'): void {\n    this.ctx.beginPath();\n    \n    series.data.forEach((point, index) => {\n      const x = this.timeToX(point.timestamp);\n      const y = this.valueToY(point.value, yAxis);\n      \n      if (index === 0) {\n        this.ctx.moveTo(x, y);\n      } else {\n        this.ctx.lineTo(x, y);\n      }\n    });\n    \n    this.ctx.stroke();\n    \n    // Draw data points\n    series.data.forEach(point => {\n      const x = this.timeToX(point.timestamp);\n      const y = this.valueToY(point.value, yAxis);\n      \n      this.ctx.beginPath();\n      this.ctx.arc(x, y, 3, 0, 2 * Math.PI);\n      this.ctx.fill();\n    });\n  }\n\n  private drawAreaSeries(series: ChartSeries, yAxis: 'left' | 'right'): void {\n    if (series.data.length < 2) return;\n    \n    // Create gradient fill\n    const gradient = this.ctx.createLinearGradient(0, this.plotArea.y, 0, this.plotArea.y + this.plotArea.height);\n    const color = series.color;\n    gradient.addColorStop(0, color + '40'); // 25% opacity\n    gradient.addColorStop(1, color + '10'); // 6% opacity\n    \n    this.ctx.fillStyle = gradient;\n    \n    this.ctx.beginPath();\n    \n    // Start from bottom-left\n    const firstPoint = series.data[0];\n    const firstX = this.timeToX(firstPoint.timestamp);\n    const bottomY = this.plotArea.y + this.plotArea.height;\n    \n    this.ctx.moveTo(firstX, bottomY);\n    \n    // Draw top line\n    series.data.forEach(point => {\n      const x = this.timeToX(point.timestamp);\n      const y = this.valueToY(point.value, yAxis);\n      this.ctx.lineTo(x, y);\n    });\n    \n    // Close to bottom-right\n    const lastPoint = series.data[series.data.length - 1];\n    const lastX = this.timeToX(lastPoint.timestamp);\n    this.ctx.lineTo(lastX, bottomY);\n    \n    this.ctx.closePath();\n    this.ctx.fill();\n    \n    // Draw line on top\n    this.ctx.strokeStyle = series.color;\n    this.ctx.lineWidth = 2;\n    this.drawLineSeries(series, yAxis);\n  }\n\n  private drawBarSeries(series: ChartSeries, yAxis: 'left' | 'right'): void {\n    const barWidth = Math.max(2, this.plotArea.width / Math.max(series.data.length, 10));\n    \n    series.data.forEach(point => {\n      const x = this.timeToX(point.timestamp);\n      const y = this.valueToY(point.value, yAxis);\n      const bottomY = this.plotArea.y + this.plotArea.height;\n      \n      this.ctx.fillRect(\n        x - barWidth / 2,\n        y,\n        barWidth,\n        bottomY - y\n      );\n    });\n  }\n\n  private drawScatterSeries(series: ChartSeries, yAxis: 'left' | 'right'): void {\n    series.data.forEach(point => {\n      const x = this.timeToX(point.timestamp);\n      const y = this.valueToY(point.value, yAxis);\n      \n      this.ctx.beginPath();\n      this.ctx.arc(x, y, 4, 0, 2 * Math.PI);\n      this.ctx.fill();\n      \n      // Add outline\n      this.ctx.strokeStyle = this.colors.background;\n      this.ctx.lineWidth = 1;\n      this.ctx.stroke();\n    });\n  }\n\n  private drawLegend(): void {\n    if (this.options.legend.position === 'none') return;\n    \n    const legendItems = this.state.series.map(series => ({\n      name: series.name,\n      color: series.color\n    }));\n    \n    if (legendItems.length === 0) return;\n    \n    // Calculate legend dimensions\n    this.ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';\n    const itemHeight = 20;\n    const itemWidth = 120;\n    \n    let legendX: number, legendY: number;\n    \n    switch (this.options.legend.position) {\n      case 'top':\n        legendX = this.plotArea.x;\n        legendY = 10;\n        break;\n      case 'bottom':\n        legendX = this.plotArea.x;\n        legendY = this.options.height - 40;\n        break;\n      case 'left':\n        legendX = 10;\n        legendY = this.plotArea.y;\n        break;\n      case 'right':\n        legendX = this.options.width - 150;\n        legendY = this.plotArea.y;\n        break;\n      default:\n        return;\n    }\n    \n    // Draw legend items\n    legendItems.forEach((item, index) => {\n      const x = legendX + (index % (this.options.legend.columns || 4)) * itemWidth;\n      const y = legendY + Math.floor(index / (this.options.legend.columns || 4)) * itemHeight;\n      \n      // Draw color indicator\n      this.ctx.fillStyle = item.color;\n      this.ctx.fillRect(x, y, 12, 12);\n      \n      // Draw text\n      this.ctx.fillStyle = this.colors.text;\n      this.ctx.textAlign = 'left';\n      this.ctx.textBaseline = 'top';\n      this.ctx.fillText(item.name, x + 16, y);\n    });\n  }\n\n  private drawTooltip(): void {\n    if (!this.options.tooltip.enabled || !this.state.hoveredPoint) return;\n    \n    const { seriesIndex, pointIndex } = this.state.hoveredPoint;\n    const series = this.state.series[seriesIndex];\n    const point = series.data[pointIndex];\n    \n    if (!series || !point) return;\n    \n    // Calculate tooltip position\n    const x = this.timeToX(point.timestamp);\n    const y = this.valueToY(point.value, series.yAxis || 'left');\n    \n    // Generate tooltip text\n    let text: string;\n    if (this.options.tooltip.format) {\n      text = this.options.tooltip.format(point, series);\n    } else {\n      text = `${series.name}\\n${this.formatTime(point.timestamp)}\\n${this.formatValue(point.value)}`;\n    }\n    \n    const lines = text.split('\\n');\n    \n    // Calculate tooltip dimensions\n    this.ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';\n    const maxWidth = Math.max(...lines.map(line => this.ctx.measureText(line).width));\n    const tooltipWidth = maxWidth + 16;\n    const tooltipHeight = lines.length * 16 + 8;\n    \n    // Position tooltip\n    let tooltipX = x + 10;\n    let tooltipY = y - tooltipHeight - 10;\n    \n    // Keep tooltip in bounds\n    if (tooltipX + tooltipWidth > this.options.width) {\n      tooltipX = x - tooltipWidth - 10;\n    }\n    if (tooltipY < 0) {\n      tooltipY = y + 10;\n    }\n    \n    // Draw tooltip background\n    this.ctx.fillStyle = this.colors.background + 'dd';\n    this.ctx.strokeStyle = this.colors.gridLines;\n    this.ctx.lineWidth = 1;\n    \n    this.ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);\n    this.ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);\n    \n    // Draw tooltip text\n    this.ctx.fillStyle = this.colors.text;\n    this.ctx.textAlign = 'left';\n    this.ctx.textBaseline = 'top';\n    \n    lines.forEach((line, index) => {\n      this.ctx.fillText(line, tooltipX + 8, tooltipY + 4 + index * 16);\n    });\n  }\n\n  private drawTitle(): void {\n    if (!this.options.title) return;\n    \n    this.ctx.fillStyle = this.colors.text;\n    this.ctx.font = '16px -apple-system, BlinkMacSystemFont, sans-serif';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'top';\n    \n    this.ctx.fillText(\n      this.options.title,\n      this.options.width / 2,\n      10\n    );\n  }\n\n  // Utility methods\n  private getDataExtents() {\n    const timeExtent = this.getTimeExtent();\n    const valueExtent = this.getValueExtent();\n    \n    return { timeExtent, valueExtent };\n  }\n\n  private getTimeExtent(): { min: number; max: number } | null {\n    if (this.state.selectedRange) {\n      return this.state.selectedRange;\n    }\n    \n    const allTimestamps = this.state.series.flatMap(s => s.data.map(p => p.timestamp));\n    if (allTimestamps.length === 0) return null;\n    \n    return {\n      min: Math.min(...allTimestamps),\n      max: Math.max(...allTimestamps)\n    };\n  }\n\n  private getValueExtent(): {\n    left?: { min: number; max: number };\n    right?: { min: number; max: number };\n  } {\n    const leftSeries = this.state.series.filter(s => (s.yAxis || 'left') === 'left');\n    const rightSeries = this.state.series.filter(s => s.yAxis === 'right');\n    \n    const result: any = {};\n    \n    if (leftSeries.length > 0) {\n      const leftValues = leftSeries.flatMap(s => s.data.map(p => p.value));\n      result.left = {\n        min: this.options.yAxis.left?.min ?? Math.min(...leftValues) * 0.95,\n        max: this.options.yAxis.left?.max ?? Math.max(...leftValues) * 1.05\n      };\n    }\n    \n    if (rightSeries.length > 0) {\n      const rightValues = rightSeries.flatMap(s => s.data.map(p => p.value));\n      result.right = {\n        min: this.options.yAxis.right?.min ?? Math.min(...rightValues) * 0.95,\n        max: this.options.yAxis.right?.max ?? Math.max(...rightValues) * 1.05\n      };\n    }\n    \n    return result;\n  }\n\n  private timeToX(timestamp: number): number {\n    const extent = this.getTimeExtent();\n    if (!extent) return this.plotArea.x;\n    \n    const ratio = (timestamp - extent.min) / (extent.max - extent.min);\n    return this.plotArea.x + ratio * this.plotArea.width;\n  }\n\n  private valueToY(value: number, yAxis: 'left' | 'right'): number {\n    const extent = this.getValueExtent();\n    const axisExtent = yAxis === 'left' ? extent.left : extent.right;\n    \n    if (!axisExtent) return this.plotArea.y + this.plotArea.height;\n    \n    const ratio = (value - axisExtent.min) / (axisExtent.max - axisExtent.min);\n    return this.plotArea.y + this.plotArea.height - ratio * this.plotArea.height;\n  }\n\n  private calculateTimeSteps(min: number, max: number): number[] {\n    const range = max - min;\n    const targetSteps = 5;\n    \n    // Determine step size based on range\n    let stepSize: number;\n    if (range < 60 * 1000) { // Less than 1 minute\n      stepSize = 10 * 1000; // 10 seconds\n    } else if (range < 60 * 60 * 1000) { // Less than 1 hour\n      stepSize = 5 * 60 * 1000; // 5 minutes\n    } else if (range < 24 * 60 * 60 * 1000) { // Less than 1 day\n      stepSize = 60 * 60 * 1000; // 1 hour\n    } else {\n      stepSize = 24 * 60 * 60 * 1000; // 1 day\n    }\n    \n    const steps: number[] = [];\n    for (let time = Math.ceil(min / stepSize) * stepSize; time <= max; time += stepSize) {\n      steps.push(time);\n    }\n    \n    return steps;\n  }\n\n  private calculateValueSteps(min: number, max: number): number[] {\n    const range = max - min;\n    const targetSteps = 5;\n    \n    // Calculate nice step size\n    const roughStep = range / targetSteps;\n    const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));\n    const normalizedStep = roughStep / magnitude;\n    \n    let niceStep: number;\n    if (normalizedStep <= 1) niceStep = 1;\n    else if (normalizedStep <= 2) niceStep = 2;\n    else if (normalizedStep <= 5) niceStep = 5;\n    else niceStep = 10;\n    \n    const stepSize = niceStep * magnitude;\n    \n    const steps: number[] = [];\n    for (let value = Math.ceil(min / stepSize) * stepSize; value <= max; value += stepSize) {\n      steps.push(value);\n    }\n    \n    return steps;\n  }\n\n  private formatTime(timestamp: number): string {\n    const date = new Date(timestamp);\n    const now = new Date();\n    \n    if (date.toDateString() === now.toDateString()) {\n      // Same day - show time only\n      return date.toLocaleTimeString('en-US', {\n        hour12: false,\n        hour: '2-digit',\n        minute: '2-digit'\n      });\n    } else {\n      // Different day - show date and time\n      return date.toLocaleString('en-US', {\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false\n      });\n    }\n  }\n\n  private formatValue(value: number, unit?: string): string {\n    let formatted: string;\n    \n    if (Math.abs(value) >= 1000000) {\n      formatted = (value / 1000000).toFixed(1) + 'M';\n    } else if (Math.abs(value) >= 1000) {\n      formatted = (value / 1000).toFixed(1) + 'K';\n    } else if (Math.abs(value) >= 1) {\n      formatted = value.toFixed(1);\n    } else {\n      formatted = value.toFixed(2);\n    }\n    \n    return unit ? `${formatted}${unit}` : formatted;\n  }\n\n  // Event handlers\n  private handleMouseMove(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n    \n    // Find closest data point\n    let closestPoint: { seriesIndex: number; pointIndex: number; distance: number } | null = null;\n    \n    this.state.series.forEach((series, seriesIndex) => {\n      series.data.forEach((point, pointIndex) => {\n        const x = this.timeToX(point.timestamp);\n        const y = this.valueToY(point.value, series.yAxis || 'left');\n        \n        const distance = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));\n        \n        if (distance <= 10 && (!closestPoint || distance < closestPoint.distance)) {\n          closestPoint = { seriesIndex, pointIndex, distance };\n        }\n      });\n    });\n    \n    // Update hovered point\n    if (closestPoint) {\n      this.state.hoveredPoint = {\n        seriesIndex: closestPoint.seriesIndex,\n        pointIndex: closestPoint.pointIndex\n      };\n      this.canvas.style.cursor = 'pointer';\n    } else {\n      this.state.hoveredPoint = null;\n      this.canvas.style.cursor = 'default';\n    }\n  }\n\n  private handleClick(event: MouseEvent): void {\n    if (this.state.hoveredPoint) {\n      const { seriesIndex, pointIndex } = this.state.hoveredPoint;\n      const series = this.state.series[seriesIndex];\n      const point = series.data[pointIndex];\n      \n      this.notifyObservers('point_clicked', { series, point, seriesIndex, pointIndex });\n    }\n  }\n\n  private handleWheel(event: WheelEvent): void {\n    if (!this.options.zoom.enabled) return;\n    \n    event.preventDefault();\n    \n    const rect = this.canvas.getBoundingClientRect();\n    const mouseX = event.clientX - rect.left;\n    \n    // Convert mouse position to time\n    const extent = this.getTimeExtent();\n    if (!extent) return;\n    \n    const mouseTime = extent.min + (mouseX - this.plotArea.x) / this.plotArea.width * (extent.max - extent.min);\n    \n    // Calculate zoom factor\n    const zoomFactor = event.deltaY > 0 ? 1.2 : 0.8;\n    \n    // Calculate new time range\n    const currentRange = extent.max - extent.min;\n    const newRange = currentRange * zoomFactor;\n    \n    const newMin = mouseTime - (mouseTime - extent.min) * zoomFactor;\n    const newMax = newMin + newRange;\n    \n    this.zoomToRange(newMin, newMax);\n  }\n\n  private handleResize(): void {\n    // Update canvas size\n    const rect = this.canvas.getBoundingClientRect();\n    this.options.width = rect.width;\n    this.options.height = rect.height;\n    \n    this.canvas.width = this.options.width * window.devicePixelRatio;\n    this.canvas.height = this.options.height * window.devicePixelRatio;\n    this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\n    \n    this.calculateLayout();\n  }\n\n  // Observer pattern\n  public subscribe(callback: (event: any) => void): () => void {\n    this.observers.push(callback);\n    \n    return () => {\n      const index = this.observers.indexOf(callback);\n      if (index > -1) {\n        this.observers.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyObservers(type: string, data: any): void {\n    this.observers.forEach(observer => {\n      try {\n        observer({ type, data, timestamp: Date.now() });\n      } catch (error) {\n        console.error('Error in chart observer:', error);\n      }\n    });\n  }\n\n  // Cleanup\n  public dispose(): void {\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n    }\n    \n    // Remove event listeners\n    this.canvas.removeEventListener('mousemove', this.handleMouseMove);\n    this.canvas.removeEventListener('click', this.handleClick);\n    this.canvas.removeEventListener('wheel', this.handleWheel);\n    window.removeEventListener('resize', this.handleResize);\n    \n    // Remove canvas from DOM\n    this.canvas.remove();\n    \n    // Clear observers\n    this.observers.length = 0;\n  }\n}\n\nexport default PerformanceChart;"