/**\n * Metrics Dashboard - Comprehensive monitoring dashboard\n * Combines multiple charts and widgets for real-time system monitoring\n */\n\nimport { PerformanceChart, ChartOptions, ChartSeries } from './PerformanceChart';\nimport { RealTimeMetrics, MetricValue, Alert } from '../RealTimeMetrics';\nimport { SystemHealth, HealthScore, ComponentHealth } from '../SystemHealth';\n\nexport interface Widget {\n  id: string;\n  type: 'chart' | 'gauge' | 'number' | 'status' | 'alert' | 'table' | 'log';\n  title: string;\n  position: { x: number; y: number };\n  size: { width: number; height: number };\n  config: Record<string, any>;\n  data?: any;\n  visible: boolean;\n}\n\nexport interface GaugeConfig {\n  min: number;\n  max: number;\n  value: number;\n  unit?: string;\n  thresholds: Array<{\n    value: number;\n    color: string;\n    label?: string;\n  }>;\n  showValue: boolean;\n  showPercentage: boolean;\n}\n\nexport interface StatusConfig {\n  items: Array<{\n    name: string;\n    status: 'healthy' | 'warning' | 'critical' | 'unknown';\n    message?: string;\n    lastUpdate: number;\n  }>;\n  layout: 'list' | 'grid' | 'compact';\n}\n\nexport interface AlertConfig {\n  maxAlerts: number;\n  severity: Array<'info' | 'warning' | 'critical' | 'emergency'>;\n  autoRefresh: boolean;\n  showResolved: boolean;\n}\n\nexport interface DashboardLayout {\n  id: string;\n  name: string;\n  widgets: Widget[];\n  gridSize: { columns: number; rows: number };\n  cellSize: { width: number; height: number };\n}\n\nexport interface DashboardConfig {\n  refreshInterval: number;\n  autoLayout: boolean;\n  theme: 'dark' | 'light' | 'auto';\n  animations: boolean;\n  performance: {\n    maxDataPoints: number;\n    compressionEnabled: boolean;\n    renderThrottling: boolean;\n  };\n}\n\nexport class MetricsDashboard {\n  private container: HTMLElement;\n  private widgets: Map<string, Widget> = new Map();\n  private charts: Map<string, PerformanceChart> = new Map();\n  private updateInterval?: NodeJS.Timeout;\n  private observers: Array<(event: any) => void> = [];\n  private isRendering: boolean = false;\n  private renderQueue: Set<string> = new Set();\n  \n  // Color schemes and styling\n  private theme = {\n    dark: {\n      background: '#1a1a1a',\n      surface: '#2d2d2d',\n      surfaceHover: '#3d3d3d',\n      text: '#ffffff',\n      textSecondary: '#cccccc',\n      textMuted: '#888888',\n      border: '#444444',\n      accent: '#00ff88',\n      warning: '#ffaa00',\n      critical: '#ff4444',\n      info: '#0088ff',\n      success: '#00ff88'\n    },\n    light: {\n      background: '#ffffff',\n      surface: '#f5f5f5',\n      surfaceHover: '#e5e5e5',\n      text: '#333333',\n      textSecondary: '#666666',\n      textMuted: '#999999',\n      border: '#dddddd',\n      accent: '#007f66',\n      warning: '#cc8800',\n      critical: '#cc3333',\n      info: '#0066cc',\n      success: '#007f66'\n    }\n  };\n\n  constructor(\n    container: HTMLElement | string,\n    private metricsMonitor: RealTimeMetrics,\n    private systemHealth: SystemHealth,\n    private config: DashboardConfig = {\n      refreshInterval: 1000,\n      autoLayout: false,\n      theme: 'dark',\n      animations: true,\n      performance: {\n        maxDataPoints: 500,\n        compressionEnabled: true,\n        renderThrottling: true\n      }\n    }\n  ) {\n    this.container = typeof container === 'string' \n      ? document.querySelector(container) as HTMLElement\n      : container;\n    \n    if (!this.container) {\n      throw new Error('Dashboard container not found');\n    }\n    \n    this.initializeDashboard();\n    this.setupEventListeners();\n    this.startUpdateLoop();\n  }\n\n  private initializeDashboard(): void {\n    // Set up container styling\n    this.container.style.cssText = `\n      position: relative;\n      width: 100%;\n      height: 100%;\n      background: ${this.theme.dark.background};\n      color: ${this.theme.dark.text};\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      overflow: auto;\n    `;\n    \n    // Create default layout\n    this.createDefaultLayout();\n  }\n\n  private createDefaultLayout(): void {\n    // System overview widgets\n    this.addWidget({\n      id: 'system-health',\n      type: 'gauge',\n      title: 'System Health',\n      position: { x: 0, y: 0 },\n      size: { width: 2, height: 2 },\n      config: {\n        min: 0,\n        max: 100,\n        value: 100,\n        unit: '%',\n        thresholds: [\n          { value: 70, color: '#ff4444', label: 'Critical' },\n          { value: 85, color: '#ffaa00', label: 'Warning' },\n          { value: 100, color: '#00ff88', label: 'Healthy' }\n        ],\n        showValue: true,\n        showPercentage: false\n      },\n      visible: true\n    });\n\n    this.addWidget({\n      id: 'performance-chart',\n      type: 'chart',\n      title: 'Performance Metrics',\n      position: { x: 2, y: 0 },\n      size: { width: 4, height: 3 },\n      config: {\n        title: 'Performance Over Time',\n        width: 600,\n        height: 300,\n        timeRange: 5 * 60 * 1000, // 5 minutes\n        refreshInterval: 1000,\n        yAxis: {\n          left: { label: 'FPS / CPU %', min: 0, max: 100 },\n          right: { label: 'Memory (MB)', min: 0, max: 500, unit: 'MB' }\n        },\n        xAxis: { label: 'Time', format: 'time' },\n        legend: { position: 'top', columns: 4 },\n        grid: { x: true, y: true },\n        zoom: { enabled: true, type: 'x' },\n        tooltip: { enabled: true },\n        thresholds: [\n          { value: 30, color: '#ffaa00', label: 'Low FPS Warning', yAxis: 'left' },\n          { value: 80, color: '#ff4444', label: 'High CPU Critical', yAxis: 'left' }\n        ]\n      },\n      visible: true\n    });\n\n    this.addWidget({\n      id: 'component-status',\n      type: 'status',\n      title: 'Component Status',\n      position: { x: 0, y: 2 },\n      size: { width: 2, height: 3 },\n      config: {\n        items: [],\n        layout: 'list'\n      },\n      visible: true\n    });\n\n    this.addWidget({\n      id: 'alerts-panel',\n      type: 'alert',\n      title: 'Active Alerts',\n      position: { x: 6, y: 0 },\n      size: { width: 2, height: 4 },\n      config: {\n        maxAlerts: 10,\n        severity: ['critical', 'warning', 'info'],\n        autoRefresh: true,\n        showResolved: false\n      },\n      visible: true\n    });\n\n    this.addWidget({\n      id: 'resource-gauges',\n      type: 'gauge',\n      title: 'Resource Usage',\n      position: { x: 2, y: 3 },\n      size: { width: 4, height: 2 },\n      config: {\n        layout: 'grid',\n        gauges: [\n          {\n            label: 'CPU',\n            min: 0,\n            max: 100,\n            value: 0,\n            unit: '%',\n            thresholds: [\n              { value: 70, color: '#ffaa00' },\n              { value: 85, color: '#ff4444' }\n            ]\n          },\n          {\n            label: 'Memory',\n            min: 0,\n            max: 100,\n            value: 0,\n            unit: '%',\n            thresholds: [\n              { value: 80, color: '#ffaa00' },\n              { value: 90, color: '#ff4444' }\n            ]\n          },\n          {\n            label: 'Network',\n            min: 0,\n            max: 1000,\n            value: 0,\n            unit: 'ms',\n            thresholds: [\n              { value: 200, color: '#ffaa00' },\n              { value: 500, color: '#ff4444' }\n            ]\n          }\n        ]\n      },\n      visible: true\n    });\n  }\n\n  private setupEventListeners(): void {\n    // Subscribe to metrics updates\n    this.metricsMonitor.subscribe('metric_update', (event) => {\n      this.handleMetricUpdate(event.data);\n    });\n\n    this.metricsMonitor.subscribe('alert_created', (event) => {\n      this.handleAlert(event.data.alert);\n    });\n\n    // Subscribe to system health updates\n    this.systemHealth.subscribe((event) => {\n      this.handleSystemHealthUpdate(event);\n    });\n\n    // Window resize handling\n    window.addEventListener('resize', () => {\n      this.handleResize();\n    });\n  }\n\n  private startUpdateLoop(): void {\n    this.updateInterval = setInterval(() => {\n      this.updateWidgets();\n    }, this.config.refreshInterval);\n    \n    // Initial update\n    this.updateWidgets();\n  }\n\n  // Widget Management\n  public addWidget(widget: Widget): void {\n    this.widgets.set(widget.id, widget);\n    this.createWidgetElement(widget);\n    this.queueRender(widget.id);\n    this.notifyObservers('widget_added', { widget });\n  }\n\n  public removeWidget(id: string): void {\n    const widget = this.widgets.get(id);\n    if (widget) {\n      this.removeWidgetElement(id);\n      this.widgets.delete(id);\n      \n      // Clean up chart if it exists\n      const chart = this.charts.get(id);\n      if (chart) {\n        chart.dispose();\n        this.charts.delete(id);\n      }\n      \n      this.notifyObservers('widget_removed', { id });\n    }\n  }\n\n  public updateWidget(id: string, updates: Partial<Widget>): void {\n    const widget = this.widgets.get(id);\n    if (widget) {\n      Object.assign(widget, updates);\n      this.queueRender(id);\n      this.notifyObservers('widget_updated', { id, updates });\n    }\n  }\n\n  public moveWidget(id: string, position: { x: number; y: number }): void {\n    this.updateWidget(id, { position });\n  }\n\n  public resizeWidget(id: string, size: { width: number; height: number }): void {\n    this.updateWidget(id, { size });\n  }\n\n  private createWidgetElement(widget: Widget): void {\n    const element = document.createElement('div');\n    element.id = `widget-${widget.id}`;\n    element.className = 'dashboard-widget';\n    \n    // Calculate position and size\n    const cellWidth = this.container.clientWidth / 8; // 8 column grid\n    const cellHeight = 150; // Fixed cell height\n    \n    element.style.cssText = `\n      position: absolute;\n      left: ${widget.position.x * cellWidth}px;\n      top: ${widget.position.y * cellHeight}px;\n      width: ${widget.size.width * cellWidth - 10}px;\n      height: ${widget.size.height * cellHeight - 10}px;\n      background: ${this.theme.dark.surface};\n      border: 1px solid ${this.theme.dark.border};\n      border-radius: 8px;\n      padding: 16px;\n      box-sizing: border-box;\n      overflow: hidden;\n      transition: ${this.config.animations ? 'all 0.3s ease' : 'none'};\n      display: ${widget.visible ? 'block' : 'none'};\n    `;\n    \n    // Add title\n    const titleElement = document.createElement('div');\n    titleElement.className = 'widget-title';\n    titleElement.textContent = widget.title;\n    titleElement.style.cssText = `\n      font-size: 14px;\n      font-weight: 600;\n      margin-bottom: 12px;\n      color: ${this.theme.dark.text};\n    `;\n    \n    element.appendChild(titleElement);\n    \n    // Add content container\n    const contentElement = document.createElement('div');\n    contentElement.className = 'widget-content';\n    contentElement.style.cssText = `\n      height: calc(100% - 32px);\n      overflow: hidden;\n    `;\n    \n    element.appendChild(contentElement);\n    \n    this.container.appendChild(element);\n  }\n\n  private removeWidgetElement(id: string): void {\n    const element = document.getElementById(`widget-${id}`);\n    if (element) {\n      element.remove();\n    }\n  }\n\n  private queueRender(widgetId: string): void {\n    this.renderQueue.add(widgetId);\n    \n    if (!this.isRendering) {\n      // Use requestAnimationFrame for smooth rendering\n      requestAnimationFrame(() => {\n        this.processRenderQueue();\n      });\n    }\n  }\n\n  private processRenderQueue(): void {\n    if (this.renderQueue.size === 0) return;\n    \n    this.isRendering = true;\n    \n    // Process all queued renders\n    for (const widgetId of this.renderQueue) {\n      const widget = this.widgets.get(widgetId);\n      if (widget) {\n        this.renderWidget(widget);\n      }\n    }\n    \n    this.renderQueue.clear();\n    this.isRendering = false;\n  }\n\n  private renderWidget(widget: Widget): void {\n    const element = document.getElementById(`widget-${widget.id}`);\n    if (!element) return;\n    \n    const contentElement = element.querySelector('.widget-content') as HTMLElement;\n    if (!contentElement) return;\n    \n    // Clear existing content\n    contentElement.innerHTML = '';\n    \n    switch (widget.type) {\n      case 'chart':\n        this.renderChartWidget(widget, contentElement);\n        break;\n      case 'gauge':\n        this.renderGaugeWidget(widget, contentElement);\n        break;\n      case 'number':\n        this.renderNumberWidget(widget, contentElement);\n        break;\n      case 'status':\n        this.renderStatusWidget(widget, contentElement);\n        break;\n      case 'alert':\n        this.renderAlertWidget(widget, contentElement);\n        break;\n      case 'table':\n        this.renderTableWidget(widget, contentElement);\n        break;\n      case 'log':\n        this.renderLogWidget(widget, contentElement);\n        break;\n    }\n  }\n\n  private renderChartWidget(widget: Widget, container: HTMLElement): void {\n    // Create chart if it doesn't exist\n    if (!this.charts.has(widget.id)) {\n      const chartOptions: ChartOptions = {\n        ...widget.config,\n        width: container.clientWidth,\n        height: container.clientHeight\n      };\n      \n      const chart = new PerformanceChart(container, chartOptions);\n      this.charts.set(widget.id, chart);\n      \n      // Subscribe to chart events\n      chart.subscribe((event) => {\n        this.notifyObservers('chart_event', { widgetId: widget.id, event });\n      });\n    }\n  }\n\n  private renderGaugeWidget(widget: Widget, container: HTMLElement): void {\n    const config = widget.config as GaugeConfig;\n    \n    if (config.layout === 'grid' && config.gauges) {\n      // Multi-gauge layout\n      config.gauges.forEach((gaugeConfig, index) => {\n        const gaugeElement = this.createGaugeElement(gaugeConfig);\n        container.appendChild(gaugeElement);\n      });\n    } else {\n      // Single gauge\n      const gaugeElement = this.createGaugeElement(config);\n      container.appendChild(gaugeElement);\n    }\n  }\n\n  private createGaugeElement(config: any): HTMLElement {\n    const gaugeContainer = document.createElement('div');\n    gaugeContainer.style.cssText = `\n      display: inline-block;\n      width: ${config.layout === 'grid' ? '33%' : '100%'};\n      text-align: center;\n      padding: 8px;\n    `;\n    \n    // Create SVG gauge\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    svg.setAttribute('width', '120');\n    svg.setAttribute('height', '120');\n    svg.style.cssText = 'margin: 0 auto; display: block;';\n    \n    // Background arc\n    const backgroundArc = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    backgroundArc.setAttribute('d', this.createArcPath(60, 60, 40, 0, 270));\n    backgroundArc.setAttribute('stroke', this.theme.dark.border);\n    backgroundArc.setAttribute('stroke-width', '8');\n    backgroundArc.setAttribute('fill', 'none');\n    svg.appendChild(backgroundArc);\n    \n    // Value arc\n    const percentage = (config.value - config.min) / (config.max - config.min);\n    const valueAngle = percentage * 270;\n    const valueColor = this.getGaugeColor(config.value, config.thresholds || []);\n    \n    const valueArc = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    valueArc.setAttribute('d', this.createArcPath(60, 60, 40, 0, valueAngle));\n    valueArc.setAttribute('stroke', valueColor);\n    valueArc.setAttribute('stroke-width', '8');\n    valueArc.setAttribute('fill', 'none');\n    valueArc.setAttribute('stroke-linecap', 'round');\n    svg.appendChild(valueArc);\n    \n    // Center text\n    const centerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    centerText.setAttribute('x', '60');\n    centerText.setAttribute('y', '65');\n    centerText.setAttribute('text-anchor', 'middle');\n    centerText.setAttribute('font-size', '16');\n    centerText.setAttribute('font-weight', 'bold');\n    centerText.setAttribute('fill', this.theme.dark.text);\n    centerText.textContent = `${config.value}${config.unit || ''}`;\n    svg.appendChild(centerText);\n    \n    gaugeContainer.appendChild(svg);\n    \n    // Label\n    if (config.label) {\n      const label = document.createElement('div');\n      label.textContent = config.label;\n      label.style.cssText = `\n        font-size: 12px;\n        color: ${this.theme.dark.textSecondary};\n        margin-top: 4px;\n      `;\n      gaugeContainer.appendChild(label);\n    }\n    \n    return gaugeContainer;\n  }\n\n  private createArcPath(x: number, y: number, radius: number, startAngle: number, endAngle: number): string {\n    const start = this.polarToCartesian(x, y, radius, endAngle);\n    const end = this.polarToCartesian(x, y, radius, startAngle);\n    const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';\n    \n    return [\n      'M', start.x, start.y,\n      'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y\n    ].join(' ');\n  }\n\n  private polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number) {\n    const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n    return {\n      x: centerX + (radius * Math.cos(angleInRadians)),\n      y: centerY + (radius * Math.sin(angleInRadians))\n    };\n  }\n\n  private getGaugeColor(value: number, thresholds: Array<{ value: number; color: string }>): string {\n    const sortedThresholds = thresholds.sort((a, b) => a.value - b.value);\n    \n    for (let i = sortedThresholds.length - 1; i >= 0; i--) {\n      if (value >= sortedThresholds[i].value) {\n        return sortedThresholds[i].color;\n      }\n    }\n    \n    return this.theme.dark.accent;\n  }\n\n  private renderNumberWidget(widget: Widget, container: HTMLElement): void {\n    const numberContainer = document.createElement('div');\n    numberContainer.style.cssText = `\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: center;\n      height: 100%;\n      text-align: center;\n    `;\n    \n    const valueElement = document.createElement('div');\n    valueElement.style.cssText = `\n      font-size: 36px;\n      font-weight: bold;\n      color: ${this.theme.dark.accent};\n      margin-bottom: 8px;\n    `;\n    valueElement.textContent = widget.data?.value?.toString() || '0';\n    \n    const labelElement = document.createElement('div');\n    labelElement.style.cssText = `\n      font-size: 14px;\n      color: ${this.theme.dark.textSecondary};\n    `;\n    labelElement.textContent = widget.config.label || '';\n    \n    numberContainer.appendChild(valueElement);\n    numberContainer.appendChild(labelElement);\n    container.appendChild(numberContainer);\n  }\n\n  private renderStatusWidget(widget: Widget, container: HTMLElement): void {\n    const config = widget.config as StatusConfig;\n    \n    const statusList = document.createElement('div');\n    statusList.style.cssText = `\n      height: 100%;\n      overflow-y: auto;\n    `;\n    \n    config.items.forEach(item => {\n      const itemElement = document.createElement('div');\n      itemElement.style.cssText = `\n        display: flex;\n        align-items: center;\n        padding: 8px 0;\n        border-bottom: 1px solid ${this.theme.dark.border};\n      `;\n      \n      // Status indicator\n      const indicator = document.createElement('div');\n      indicator.style.cssText = `\n        width: 8px;\n        height: 8px;\n        border-radius: 50%;\n        background: ${this.getStatusColor(item.status)};\n        margin-right: 12px;\n        flex-shrink: 0;\n      `;\n      \n      // Item name\n      const name = document.createElement('div');\n      name.style.cssText = `\n        font-weight: 500;\n        color: ${this.theme.dark.text};\n        flex: 1;\n      `;\n      name.textContent = item.name;\n      \n      // Last update\n      const lastUpdate = document.createElement('div');\n      lastUpdate.style.cssText = `\n        font-size: 11px;\n        color: ${this.theme.dark.textMuted};\n        margin-left: 8px;\n      `;\n      lastUpdate.textContent = this.formatTimestamp(item.lastUpdate);\n      \n      itemElement.appendChild(indicator);\n      itemElement.appendChild(name);\n      itemElement.appendChild(lastUpdate);\n      \n      statusList.appendChild(itemElement);\n    });\n    \n    container.appendChild(statusList);\n  }\n\n  private renderAlertWidget(widget: Widget, container: HTMLElement): void {\n    const config = widget.config as AlertConfig;\n    \n    const alertsList = document.createElement('div');\n    alertsList.style.cssText = `\n      height: 100%;\n      overflow-y: auto;\n    `;\n    \n    // Get alerts from system\n    const alerts = this.systemHealth.getAlerts(config.showResolved)\n      .filter(alert => config.severity.includes(alert.severity))\n      .slice(0, config.maxAlerts);\n    \n    if (alerts.length === 0) {\n      const noAlerts = document.createElement('div');\n      noAlerts.style.cssText = `\n        text-align: center;\n        color: ${this.theme.dark.textMuted};\n        padding: 20px;\n      `;\n      noAlerts.textContent = 'No active alerts';\n      alertsList.appendChild(noAlerts);\n    } else {\n      alerts.forEach(alert => {\n        const alertElement = document.createElement('div');\n        alertElement.style.cssText = `\n          padding: 12px;\n          margin-bottom: 8px;\n          background: ${this.theme.dark.surfaceHover};\n          border-left: 4px solid ${this.getSeverityColor(alert.severity)};\n          border-radius: 4px;\n        `;\n        \n        // Alert header\n        const header = document.createElement('div');\n        header.style.cssText = `\n          display: flex;\n          justify-content: between;\n          align-items: center;\n          margin-bottom: 4px;\n        `;\n        \n        const severity = document.createElement('span');\n        severity.style.cssText = `\n          font-size: 10px;\n          font-weight: bold;\n          text-transform: uppercase;\n          color: ${this.getSeverityColor(alert.severity)};\n        `;\n        severity.textContent = alert.severity;\n        \n        const timestamp = document.createElement('span');\n        timestamp.style.cssText = `\n          font-size: 10px;\n          color: ${this.theme.dark.textMuted};\n          margin-left: auto;\n        `;\n        timestamp.textContent = this.formatTimestamp(alert.timestamp);\n        \n        header.appendChild(severity);\n        header.appendChild(timestamp);\n        \n        // Alert message\n        const message = document.createElement('div');\n        message.style.cssText = `\n          font-size: 12px;\n          color: ${this.theme.dark.text};\n          line-height: 1.4;\n        `;\n        message.textContent = alert.message;\n        \n        alertElement.appendChild(header);\n        alertElement.appendChild(message);\n        alertsList.appendChild(alertElement);\n      });\n    }\n    \n    container.appendChild(alertsList);\n  }\n\n  private renderTableWidget(widget: Widget, container: HTMLElement): void {\n    // Implementation for table widget\n    const table = document.createElement('table');\n    table.style.cssText = `\n      width: 100%;\n      border-collapse: collapse;\n      font-size: 12px;\n    `;\n    \n    // Add table content based on widget.data\n    container.appendChild(table);\n  }\n\n  private renderLogWidget(widget: Widget, container: HTMLElement): void {\n    // Implementation for log widget\n    const logContainer = document.createElement('div');\n    logContainer.style.cssText = `\n      height: 100%;\n      overflow-y: auto;\n      font-family: monospace;\n      font-size: 11px;\n      background: ${this.theme.dark.background};\n      padding: 8px;\n    `;\n    \n    container.appendChild(logContainer);\n  }\n\n  // Event Handlers\n  private handleMetricUpdate(data: any): void {\n    const { metric, value } = data;\n    \n    // Update performance chart\n    const chart = this.charts.get('performance-chart');\n    if (chart && metric.name) {\n      chart.addDataPoint(metric.name, {\n        timestamp: value.timestamp,\n        value: value.value\n      });\n    }\n    \n    // Update gauges\n    if (metric.name === 'system.cpu.usage') {\n      const widget = this.widgets.get('resource-gauges');\n      if (widget && widget.config.gauges) {\n        widget.config.gauges[0].value = value.value;\n        this.queueRender('resource-gauges');\n      }\n    }\n  }\n\n  private handleAlert(alert: Alert): void {\n    // Force refresh of alert widget\n    this.queueRender('alerts-panel');\n  }\n\n  private handleSystemHealthUpdate(event: any): void {\n    if (event.type === 'health_score_updated') {\n      const score = event.data.score as HealthScore;\n      \n      // Update system health gauge\n      const healthWidget = this.widgets.get('system-health');\n      if (healthWidget) {\n        healthWidget.config.value = score.overall;\n        this.queueRender('system-health');\n      }\n      \n      // Update component status\n      const statusWidget = this.widgets.get('component-status');\n      if (statusWidget) {\n        const components = this.systemHealth.getComponentHealth();\n        statusWidget.config.items = components.map(comp => ({\n          name: comp.name,\n          status: comp.status,\n          message: `${comp.responseTime.toFixed(1)}ms`,\n          lastUpdate: comp.lastCheck\n        }));\n        this.queueRender('component-status');\n      }\n    }\n  }\n\n  private handleResize(): void {\n    // Update widget positions and sizes\n    this.widgets.forEach(widget => {\n      this.queueRender(widget.id);\n    });\n  }\n\n  private updateWidgets(): void {\n    // Update data for all widgets\n    this.widgets.forEach(widget => {\n      if (widget.visible) {\n        this.updateWidgetData(widget);\n      }\n    });\n  }\n\n  private updateWidgetData(widget: Widget): void {\n    switch (widget.type) {\n      case 'chart':\n        // Charts update themselves via subscriptions\n        break;\n      \n      case 'gauge':\n        // Update gauge values from metrics\n        this.updateGaugeData(widget);\n        break;\n      \n      case 'number':\n        // Update number widgets\n        this.updateNumberData(widget);\n        break;\n      \n      case 'status':\n      case 'alert':\n        // These update via event handlers\n        break;\n    }\n  }\n\n  private updateGaugeData(widget: Widget): void {\n    // Update gauge values from latest metrics\n    // This would be implemented based on specific metric mappings\n  }\n\n  private updateNumberData(widget: Widget): void {\n    // Update number values from latest metrics\n    // This would be implemented based on specific metric mappings\n  }\n\n  // Utility methods\n  private getStatusColor(status: string): string {\n    switch (status) {\n      case 'healthy': return this.theme.dark.success;\n      case 'warning': return this.theme.dark.warning;\n      case 'critical': return this.theme.dark.critical;\n      default: return this.theme.dark.textMuted;\n    }\n  }\n\n  private getSeverityColor(severity: string): string {\n    switch (severity) {\n      case 'info': return this.theme.dark.info;\n      case 'warning': return this.theme.dark.warning;\n      case 'critical': return this.theme.dark.critical;\n      case 'emergency': return '#ff0000';\n      default: return this.theme.dark.textMuted;\n    }\n  }\n\n  private formatTimestamp(timestamp: number): string {\n    const now = Date.now();\n    const diff = now - timestamp;\n    \n    if (diff < 60 * 1000) {\n      return `${Math.floor(diff / 1000)}s ago`;\n    } else if (diff < 60 * 60 * 1000) {\n      return `${Math.floor(diff / (60 * 1000))}m ago`;\n    } else {\n      return new Date(timestamp).toLocaleTimeString();\n    }\n  }\n\n  // Public API\n  public getWidget(id: string): Widget | undefined {\n    return this.widgets.get(id);\n  }\n\n  public getAllWidgets(): Widget[] {\n    return Array.from(this.widgets.values());\n  }\n\n  public showWidget(id: string): void {\n    this.updateWidget(id, { visible: true });\n  }\n\n  public hideWidget(id: string): void {\n    this.updateWidget(id, { visible: false });\n  }\n\n  public exportLayout(): DashboardLayout {\n    return {\n      id: 'default',\n      name: 'Default Layout',\n      widgets: Array.from(this.widgets.values()),\n      gridSize: { columns: 8, rows: 6 },\n      cellSize: { width: 100, height: 150 }\n    };\n  }\n\n  public importLayout(layout: DashboardLayout): void {\n    // Clear existing widgets\n    this.widgets.clear();\n    this.charts.forEach(chart => chart.dispose());\n    this.charts.clear();\n    this.container.innerHTML = '';\n    \n    // Add layout widgets\n    layout.widgets.forEach(widget => {\n      this.addWidget(widget);\n    });\n  }\n\n  // Observer pattern\n  public subscribe(callback: (event: any) => void): () => void {\n    this.observers.push(callback);\n    \n    return () => {\n      const index = this.observers.indexOf(callback);\n      if (index > -1) {\n        this.observers.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyObservers(type: string, data: any): void {\n    this.observers.forEach(observer => {\n      try {\n        observer({ type, data, timestamp: Date.now() });\n      } catch (error) {\n        console.error('Error in dashboard observer:', error);\n      }\n    });\n  }\n\n  // Cleanup\n  public dispose(): void {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval);\n    }\n    \n    // Dispose all charts\n    this.charts.forEach(chart => chart.dispose());\n    \n    // Clear container\n    this.container.innerHTML = '';\n    \n    // Clear collections\n    this.widgets.clear();\n    this.charts.clear();\n    this.observers.length = 0;\n  }\n}\n\nexport default MetricsDashboard;"