/**
 * Error Monitor for CLI UI
 * Automatic error capture, categorization, and recovery system
 */\n\nexport interface ErrorStackFrame {\n  function: string;\n  file: string;\n  line: number;\n  column: number;\n  source?: string;\n}\n\nexport interface ErrorContext {\n  userId?: string;\n  sessionId: string;\n  command?: string;\n  parameters?: Record<string, any>;\n  environment: {\n    platform: string;\n    nodeVersion?: string;\n    cliVersion: string;\n    workingDirectory: string;\n  };\n  state?: Record<string, any>;\n  breadcrumbs: Breadcrumb[];\n}\n\nexport interface Breadcrumb {\n  timestamp: number;\n  category: 'navigation' | 'user' | 'system' | 'network' | 'debug';\n  message: string;\n  level: 'info' | 'debug' | 'warning' | 'error';\n  data?: Record<string, any>;\n}\n\nexport interface CapturedError {\n  id: string;\n  type: string;\n  message: string;\n  stack: string;\n  stackFrames: ErrorStackFrame[];\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  category: 'system' | 'validation' | 'network' | 'runtime' | 'user' | 'unknown';\n  timestamp: number;\n  context: ErrorContext;\n  frequency: number;\n  firstOccurred: number;\n  lastOccurred: number;\n  resolved: boolean;\n  tags: string[];\n  fingerprint: string; // For grouping similar errors\n}\n\nexport interface RecoveryAction {\n  id: string;\n  name: string;\n  description: string;\n  category: string;\n  automated: boolean;\n  successRate: number;\n  averageTime: number;\n  implementation: (error: CapturedError, context: ErrorContext) => Promise<RecoveryResult>;\n}\n\nexport interface RecoveryResult {\n  success: boolean;\n  message: string;\n  duration: number;\n  actions: string[];\n  metadata?: Record<string, any>;\n}\n\nexport interface ErrorPattern {\n  pattern: string;\n  category: string;\n  severity: CapturedError['severity'];\n  description: string;\n  frequency: number;\n  examples: string[];\n  suggestedFixes: string[];\n}\n\nexport interface ErrorSummary {\n  totalErrors: number;\n  errorsByCategory: Record<string, number>;\n  errorsBySeverity: Record<string, number>;\n  topErrors: CapturedError[];\n  patterns: ErrorPattern[];\n  recoveryStats: {\n    attempted: number;\n    successful: number;\n    averageTime: number;\n    topActions: Array<{ action: string; successRate: number }>;\n  };\n  trend: {\n    direction: 'increasing' | 'decreasing' | 'stable';\n    percentage: number;\n    timeframe: string;\n  };\n}\n\nexport class ErrorMonitor {\n  private errors: Map<string, CapturedError> = new Map();\n  private breadcrumbs: Breadcrumb[] = [];\n  private recoveryActions: Map<string, RecoveryAction> = new Map();\n  private observers: Array<(error: CapturedError) => void> = [];\n  private isActive: boolean = false;\n  private sessionId: string;\n  private maxBreadcrumbs: number = 50;\n  private maxErrors: number = 1000;\n  private patternCache: Map<string, ErrorPattern> = new Map();\n  \n  constructor(sessionId?: string) {\n    this.sessionId = sessionId || this.generateSessionId();\n    this.initializeRecoveryActions();\n    this.setupGlobalErrorHandlers();\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private initializeRecoveryActions(): void {\n    const actions: RecoveryAction[] = [\n      {\n        id: 'retry_command',\n        name: 'Retry Command',\n        description: 'Automatically retry the failed command',\n        category: 'retry',\n        automated: true,\n        successRate: 0.6,\n        averageTime: 1000,\n        implementation: this.retryCommandAction.bind(this)\n      },\n      {\n        id: 'clear_cache',\n        name: 'Clear Cache',\n        description: 'Clear relevant caches and retry',\n        category: 'cleanup',\n        automated: true,\n        successRate: 0.4,\n        averageTime: 2000,\n        implementation: this.clearCacheAction.bind(this)\n      },\n      {\n        id: 'restart_service',\n        name: 'Restart Service',\n        description: 'Restart affected service or component',\n        category: 'restart',\n        automated: false,\n        successRate: 0.8,\n        averageTime: 5000,\n        implementation: this.restartServiceAction.bind(this)\n      },\n      {\n        id: 'validate_input',\n        name: 'Validate Input',\n        description: 'Validate and sanitize user input',\n        category: 'validation',\n        automated: true,\n        successRate: 0.9,\n        averageTime: 500,\n        implementation: this.validateInputAction.bind(this)\n      },\n      {\n        id: 'fallback_mode',\n        name: 'Fallback Mode',\n        description: 'Switch to fallback implementation',\n        category: 'fallback',\n        automated: true,\n        successRate: 0.7,\n        averageTime: 1500,\n        implementation: this.fallbackModeAction.bind(this)\n      }\n    ];\n\n    actions.forEach(action => {\n      this.recoveryActions.set(action.id, action);\n    });\n  }\n\n  private setupGlobalErrorHandlers(): void {\n    if (typeof process !== 'undefined') {\n      // Node.js environment\n      process.on('uncaughtException', (error: Error) => {\n        this.captureError(error, 'critical', 'system', {\n          source: 'uncaughtException'\n        });\n      });\n\n      process.on('unhandledRejection', (reason: any) => {\n        const error = reason instanceof Error ? reason : new Error(String(reason));\n        this.captureError(error, 'high', 'runtime', {\n          source: 'unhandledRejection',\n          reason\n        });\n      });\n    }\n\n    if (typeof window !== 'undefined') {\n      // Browser environment\n      window.addEventListener('error', (event) => {\n        this.captureError(event.error, 'high', 'runtime', {\n          source: 'window.error',\n          filename: event.filename,\n          lineno: event.lineno,\n          colno: event.colno\n        });\n      });\n\n      window.addEventListener('unhandledrejection', (event) => {\n        const error = event.reason instanceof Error ? event.reason : new Error(String(event.reason));\n        this.captureError(error, 'high', 'runtime', {\n          source: 'unhandledrejection'\n        });\n      });\n    }\n  }\n\n  public start(): void {\n    this.isActive = true;\n    this.addBreadcrumb('system', 'Error monitor started', 'info');\n    console.log('Error monitor activated');\n  }\n\n  public stop(): void {\n    this.isActive = false;\n    this.addBreadcrumb('system', 'Error monitor stopped', 'info');\n    console.log('Error monitor deactivated');\n  }\n\n  // Error Capture Methods\n  public captureError(\n    error: Error | string,\n    severity: CapturedError['severity'] = 'medium',\n    category: CapturedError['category'] = 'unknown',\n    additionalContext?: Record<string, any>\n  ): CapturedError {\n    if (!this.isActive) return this.createErrorStub(error);\n\n    const errorObj = typeof error === 'string' ? new Error(error) : error;\n    const fingerprint = this.generateFingerprint(errorObj);\n    const existingError = Array.from(this.errors.values()).find(e => e.fingerprint === fingerprint);\n    \n    if (existingError) {\n      // Update existing error\n      existingError.frequency += 1;\n      existingError.lastOccurred = Date.now();\n      existingError.context = this.buildErrorContext(additionalContext);\n      \n      this.notifyObservers(existingError);\n      return existingError;\n    }\n\n    // Create new error entry\n    const capturedError: CapturedError = {\n      id: this.generateErrorId(),\n      type: errorObj.name || 'Error',\n      message: errorObj.message,\n      stack: errorObj.stack || '',\n      stackFrames: this.parseStackTrace(errorObj.stack || ''),\n      severity,\n      category: this.categorizeError(errorObj, category),\n      timestamp: Date.now(),\n      context: this.buildErrorContext(additionalContext),\n      frequency: 1,\n      firstOccurred: Date.now(),\n      lastOccurred: Date.now(),\n      resolved: false,\n      tags: this.generateTags(errorObj, category),\n      fingerprint\n    };\n\n    this.errors.set(capturedError.id, capturedError);\n    \n    // Limit error storage\n    if (this.errors.size > this.maxErrors) {\n      this.pruneOldErrors();\n    }\n\n    this.addBreadcrumb('system', `Error captured: ${errorObj.message}`, 'error', {\n      errorId: capturedError.id,\n      type: capturedError.type\n    });\n\n    this.notifyObservers(capturedError);\n    \n    // Attempt automatic recovery\n    if (severity !== 'low') {\n      this.attemptRecovery(capturedError);\n    }\n\n    return capturedError;\n  }\n\n  private createErrorStub(error: Error | string): CapturedError {\n    const errorObj = typeof error === 'string' ? new Error(error) : error;\n    return {\n      id: 'inactive',\n      type: errorObj.name || 'Error',\n      message: errorObj.message,\n      stack: '',\n      stackFrames: [],\n      severity: 'low',\n      category: 'unknown',\n      timestamp: Date.now(),\n      context: this.buildErrorContext(),\n      frequency: 1,\n      firstOccurred: Date.now(),\n      lastOccurred: Date.now(),\n      resolved: false,\n      tags: [],\n      fingerprint: ''\n    };\n  }\n\n  private generateErrorId(): string {\n    return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateFingerprint(error: Error): string {\n    // Create a fingerprint based on error type, message pattern, and stack location\n    const message = error.message.replace(/\\d+/g, 'N').replace(/[\"']/g, ''); // Normalize\n    const topFrame = this.parseStackTrace(error.stack || '')[0];\n    const location = topFrame ? `${topFrame.file}:${topFrame.function}` : 'unknown';\n    \n    const fingerprint = `${error.name}:${message}:${location}`;\n    \n    // Simple hash function\n    let hash = 0;\n    for (let i = 0; i < fingerprint.length; i++) {\n      const char = fingerprint.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    return hash.toString(36);\n  }\n\n  private parseStackTrace(stack: string): ErrorStackFrame[] {\n    if (!stack) return [];\n    \n    const frames: ErrorStackFrame[] = [];\n    const lines = stack.split('\\n');\n    \n    for (const line of lines) {\n      // Parse different stack trace formats\n      let match;\n      \n      // V8 format: \"    at functionName (file:line:column)\"\n      match = line.match(/\\s+at\\s+(.+?)\\s+\\((.+?):(\\d+):(\\d+)\\)/);\n      if (match) {\n        frames.push({\n          function: match[1],\n          file: match[2],\n          line: parseInt(match[3]),\n          column: parseInt(match[4]),\n          source: line.trim()\n        });\n        continue;\n      }\n      \n      // V8 format: \"    at file:line:column\"\n      match = line.match(/\\s+at\\s+(.+?):(\\d+):(\\d+)/);\n      if (match) {\n        frames.push({\n          function: 'anonymous',\n          file: match[1],\n          line: parseInt(match[2]),\n          column: parseInt(match[3]),\n          source: line.trim()\n        });\n        continue;\n      }\n      \n      // Other formats\n      if (line.trim() && !line.includes('Error:')) {\n        frames.push({\n          function: 'unknown',\n          file: 'unknown',\n          line: 0,\n          column: 0,\n          source: line.trim()\n        });\n      }\n    }\n    \n    return frames;\n  }\n\n  private categorizeError(error: Error, providedCategory: CapturedError['category']): CapturedError['category'] {\n    if (providedCategory !== 'unknown') return providedCategory;\n    \n    const message = error.message.toLowerCase();\n    const stack = error.stack?.toLowerCase() || '';\n    \n    if (message.includes('network') || message.includes('fetch') || message.includes('connection')) {\n      return 'network';\n    }\n    \n    if (message.includes('validation') || message.includes('invalid') || message.includes('required')) {\n      return 'validation';\n    }\n    \n    if (error.name === 'ReferenceError' || error.name === 'TypeError' || error.name === 'SyntaxError') {\n      return 'runtime';\n    }\n    \n    if (stack.includes('fs.') || stack.includes('process.') || message.includes('permission')) {\n      return 'system';\n    }\n    \n    return 'unknown';\n  }\n\n  private generateTags(error: Error, category: CapturedError['category']): string[] {\n    const tags: string[] = [];\n    \n    tags.push(`type:${error.name}`);\n    tags.push(`category:${category}`);\n    \n    const message = error.message.toLowerCase();\n    \n    if (message.includes('timeout')) tags.push('timeout');\n    if (message.includes('permission')) tags.push('permission');\n    if (message.includes('not found')) tags.push('not-found');\n    if (message.includes('network')) tags.push('network');\n    if (message.includes('syntax')) tags.push('syntax');\n    \n    return tags;\n  }\n\n  private buildErrorContext(additionalContext?: Record<string, any>): ErrorContext {\n    return {\n      sessionId: this.sessionId,\n      environment: {\n        platform: typeof process !== 'undefined' ? process.platform : 'browser',\n        nodeVersion: typeof process !== 'undefined' ? process.version : undefined,\n        cliVersion: '1.0.0', // Should be dynamically determined\n        workingDirectory: typeof process !== 'undefined' ? process.cwd() : '/'\n      },\n      breadcrumbs: [...this.breadcrumbs],\n      ...additionalContext\n    };\n  }\n\n  private pruneOldErrors(): void {\n    const sortedErrors = Array.from(this.errors.values())\n      .sort((a, b) => a.lastOccurred - b.lastOccurred);\n    \n    const toRemove = sortedErrors.slice(0, Math.floor(this.maxErrors * 0.1));\n    toRemove.forEach(error => this.errors.delete(error.id));\n  }\n\n  // Breadcrumb Management\n  public addBreadcrumb(\n    category: Breadcrumb['category'],\n    message: string,\n    level: Breadcrumb['level'] = 'info',\n    data?: Record<string, any>\n  ): void {\n    const breadcrumb: Breadcrumb = {\n      timestamp: Date.now(),\n      category,\n      message,\n      level,\n      data\n    };\n    \n    this.breadcrumbs.push(breadcrumb);\n    \n    if (this.breadcrumbs.length > this.maxBreadcrumbs) {\n      this.breadcrumbs.shift();\n    }\n  }\n\n  public getBreadcrumbs(): Breadcrumb[] {\n    return [...this.breadcrumbs];\n  }\n\n  // Recovery System\n  private async attemptRecovery(error: CapturedError): Promise<void> {\n    const suitableActions = this.findSuitableRecoveryActions(error);\n    \n    for (const action of suitableActions.slice(0, 3)) { // Try top 3 actions\n      if (!action.automated) continue; // Skip manual actions in auto-recovery\n      \n      try {\n        this.addBreadcrumb('system', `Attempting recovery: ${action.name}`, 'info', {\n          errorId: error.id,\n          actionId: action.id\n        });\n        \n        const result = await action.implementation(error, error.context);\n        \n        if (result.success) {\n          error.resolved = true;\n          this.addBreadcrumb('system', `Recovery successful: ${action.name}`, 'info', {\n            errorId: error.id,\n            actionId: action.id,\n            duration: result.duration\n          });\n          \n          // Update action success rate\n          action.successRate = (action.successRate * 0.9) + (0.1 * 1); // Weighted average\n          \n          break;\n        } else {\n          this.addBreadcrumb('system', `Recovery failed: ${action.name} - ${result.message}`, 'warning', {\n            errorId: error.id,\n            actionId: action.id\n          });\n          \n          // Update action success rate\n          action.successRate = (action.successRate * 0.9) + (0.1 * 0);\n        }\n      } catch (recoveryError) {\n        this.addBreadcrumb('system', `Recovery error: ${action.name}`, 'error', {\n          errorId: error.id,\n          actionId: action.id,\n          error: recoveryError\n        });\n      }\n    }\n  }\n\n  private findSuitableRecoveryActions(error: CapturedError): RecoveryAction[] {\n    const actions = Array.from(this.recoveryActions.values());\n    \n    // Score actions based on error characteristics\n    const scored = actions.map(action => ({\n      action,\n      score: this.scoreRecoveryAction(action, error)\n    }));\n    \n    return scored\n      .sort((a, b) => b.score - a.score)\n      .map(item => item.action);\n  }\n\n  private scoreRecoveryAction(action: RecoveryAction, error: CapturedError): number {\n    let score = action.successRate;\n    \n    // Boost score for category matches\n    if (action.category === 'retry' && error.category === 'network') score += 0.3;\n    if (action.category === 'validation' && error.category === 'validation') score += 0.4;\n    if (action.category === 'cleanup' && error.category === 'system') score += 0.2;\n    \n    // Consider error severity\n    if (error.severity === 'critical' && action.category === 'restart') score += 0.2;\n    \n    // Prefer faster actions for frequent errors\n    if (error.frequency > 5) {\n      score += Math.max(0, (5000 - action.averageTime) / 5000) * 0.1;\n    }\n    \n    return Math.min(1, score);\n  }\n\n  // Recovery Action Implementations\n  private async retryCommandAction(error: CapturedError, context: ErrorContext): Promise<RecoveryResult> {\n    const start = Date.now();\n    \n    try {\n      // Simulate retry logic\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      return {\n        success: Math.random() > 0.4, // 60% success rate\n        message: 'Command retried successfully',\n        duration: Date.now() - start,\n        actions: ['retry_command']\n      };\n    } catch (retryError) {\n      return {\n        success: false,\n        message: `Retry failed: ${retryError}`,\n        duration: Date.now() - start,\n        actions: ['retry_command']\n      };\n    }\n  }\n\n  private async clearCacheAction(error: CapturedError, context: ErrorContext): Promise<RecoveryResult> {\n    const start = Date.now();\n    \n    try {\n      // Simulate cache clearing\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      return {\n        success: Math.random() > 0.6, // 40% success rate\n        message: 'Cache cleared successfully',\n        duration: Date.now() - start,\n        actions: ['clear_cache']\n      };\n    } catch (clearError) {\n      return {\n        success: false,\n        message: `Cache clear failed: ${clearError}`,\n        duration: Date.now() - start,\n        actions: ['clear_cache']\n      };\n    }\n  }\n\n  private async restartServiceAction(error: CapturedError, context: ErrorContext): Promise<RecoveryResult> {\n    const start = Date.now();\n    \n    try {\n      // Simulate service restart\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      return {\n        success: Math.random() > 0.2, // 80% success rate\n        message: 'Service restarted successfully',\n        duration: Date.now() - start,\n        actions: ['restart_service']\n      };\n    } catch (restartError) {\n      return {\n        success: false,\n        message: `Service restart failed: ${restartError}`,\n        duration: Date.now() - start,\n        actions: ['restart_service']\n      };\n    }\n  }\n\n  private async validateInputAction(error: CapturedError, context: ErrorContext): Promise<RecoveryResult> {\n    const start = Date.now();\n    \n    try {\n      // Simulate input validation\n      await new Promise(resolve => setTimeout(resolve, 50));\n      \n      return {\n        success: Math.random() > 0.1, // 90% success rate\n        message: 'Input validated and sanitized',\n        duration: Date.now() - start,\n        actions: ['validate_input']\n      };\n    } catch (validationError) {\n      return {\n        success: false,\n        message: `Input validation failed: ${validationError}`,\n        duration: Date.now() - start,\n        actions: ['validate_input']\n      };\n    }\n  }\n\n  private async fallbackModeAction(error: CapturedError, context: ErrorContext): Promise<RecoveryResult> {\n    const start = Date.now();\n    \n    try {\n      // Simulate fallback mode\n      await new Promise(resolve => setTimeout(resolve, 150));\n      \n      return {\n        success: Math.random() > 0.3, // 70% success rate\n        message: 'Switched to fallback mode',\n        duration: Date.now() - start,\n        actions: ['fallback_mode']\n      };\n    } catch (fallbackError) {\n      return {\n        success: false,\n        message: `Fallback mode failed: ${fallbackError}`,\n        duration: Date.now() - start,\n        actions: ['fallback_mode']\n      };\n    }\n  }\n\n  // Analysis and Reporting\n  public getErrorSummary(timeRange?: number): ErrorSummary {\n    const cutoff = timeRange ? Date.now() - timeRange : 0;\n    const relevantErrors = Array.from(this.errors.values())\n      .filter(error => error.timestamp >= cutoff);\n    \n    const errorsByCategory: Record<string, number> = {};\n    const errorsBySeverity: Record<string, number> = {};\n    \n    relevantErrors.forEach(error => {\n      errorsByCategory[error.category] = (errorsByCategory[error.category] || 0) + error.frequency;\n      errorsBySeverity[error.severity] = (errorsBySeverity[error.severity] || 0) + error.frequency;\n    });\n    \n    const topErrors = relevantErrors\n      .sort((a, b) => b.frequency - a.frequency)\n      .slice(0, 10);\n    \n    const patterns = this.analyzePatterns(relevantErrors);\n    \n    return {\n      totalErrors: relevantErrors.reduce((sum, e) => sum + e.frequency, 0),\n      errorsByCategory,\n      errorsBySeverity,\n      topErrors,\n      patterns,\n      recoveryStats: this.calculateRecoveryStats(relevantErrors),\n      trend: this.calculateTrend(relevantErrors, timeRange)\n    };\n  }\n\n  private analyzePatterns(errors: CapturedError[]): ErrorPattern[] {\n    const patternGroups = new Map<string, CapturedError[]>();\n    \n    // Group errors by fingerprint\n    errors.forEach(error => {\n      const group = patternGroups.get(error.fingerprint) || [];\n      group.push(error);\n      patternGroups.set(error.fingerprint, group);\n    });\n    \n    const patterns: ErrorPattern[] = [];\n    \n    patternGroups.forEach((group, fingerprint) => {\n      if (group.length < 2) return; // Skip single occurrences\n      \n      const representative = group[0];\n      const totalFrequency = group.reduce((sum, e) => sum + e.frequency, 0);\n      \n      patterns.push({\n        pattern: fingerprint,\n        category: representative.category,\n        severity: representative.severity,\n        description: representative.message,\n        frequency: totalFrequency,\n        examples: group.slice(0, 3).map(e => e.message),\n        suggestedFixes: this.generateSuggestedFixes(representative)\n      });\n    });\n    \n    return patterns.sort((a, b) => b.frequency - a.frequency);\n  }\n\n  private generateSuggestedFixes(error: CapturedError): string[] {\n    const fixes: string[] = [];\n    \n    switch (error.category) {\n      case 'network':\n        fixes.push('Check network connectivity');\n        fixes.push('Verify API endpoints are accessible');\n        fixes.push('Implement retry logic with exponential backoff');\n        break;\n      \n      case 'validation':\n        fixes.push('Add input validation');\n        fixes.push('Sanitize user inputs');\n        fixes.push('Implement proper error messages');\n        break;\n      \n      case 'runtime':\n        fixes.push('Add null/undefined checks');\n        fixes.push('Validate object properties before access');\n        fixes.push('Use try-catch blocks for risky operations');\n        break;\n      \n      case 'system':\n        fixes.push('Check file permissions');\n        fixes.push('Verify system dependencies');\n        fixes.push('Handle environment-specific differences');\n        break;\n      \n      default:\n        fixes.push('Add proper error handling');\n        fixes.push('Log more context information');\n        fixes.push('Consider edge cases');\n    }\n    \n    return fixes;\n  }\n\n  private calculateRecoveryStats(errors: CapturedError[]): ErrorSummary['recoveryStats'] {\n    const recovered = errors.filter(e => e.resolved);\n    \n    return {\n      attempted: errors.length,\n      successful: recovered.length,\n      averageTime: 2000, // Would calculate from actual recovery times\n      topActions: [\n        { action: 'retry_command', successRate: 0.6 },\n        { action: 'validate_input', successRate: 0.9 },\n        { action: 'fallback_mode', successRate: 0.7 }\n      ]\n    };\n  }\n\n  private calculateTrend(errors: CapturedError[], timeRange?: number): ErrorSummary['trend'] {\n    if (errors.length < 2) {\n      return { direction: 'stable', percentage: 0, timeframe: '24h' };\n    }\n    \n    const now = Date.now();\n    const range = timeRange || 24 * 60 * 60 * 1000; // 24 hours\n    const halfRange = range / 2;\n    \n    const recentErrors = errors.filter(e => e.timestamp >= (now - halfRange));\n    const olderErrors = errors.filter(e => e.timestamp >= (now - range) && e.timestamp < (now - halfRange));\n    \n    const recentCount = recentErrors.reduce((sum, e) => sum + e.frequency, 0);\n    const olderCount = olderErrors.reduce((sum, e) => sum + e.frequency, 0);\n    \n    if (olderCount === 0) {\n      return { direction: 'stable', percentage: 0, timeframe: '12h' };\n    }\n    \n    const percentageChange = ((recentCount - olderCount) / olderCount) * 100;\n    \n    let direction: 'increasing' | 'decreasing' | 'stable';\n    if (Math.abs(percentageChange) < 10) {\n      direction = 'stable';\n    } else if (percentageChange > 0) {\n      direction = 'increasing';\n    } else {\n      direction = 'decreasing';\n    }\n    \n    return {\n      direction,\n      percentage: Math.abs(percentageChange),\n      timeframe: '12h'\n    };\n  }\n\n  // Observer Pattern\n  public onError(callback: (error: CapturedError) => void): () => void {\n    this.observers.push(callback);\n    \n    return () => {\n      const index = this.observers.indexOf(callback);\n      if (index > -1) {\n        this.observers.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyObservers(error: CapturedError): void {\n    this.observers.forEach(callback => {\n      try {\n        callback(error);\n      } catch (observerError) {\n        console.error('Error in error observer:', observerError);\n      }\n    });\n  }\n\n  // Data Access and Management\n  public getErrors(filters?: {\n    category?: CapturedError['category'];\n    severity?: CapturedError['severity'];\n    resolved?: boolean;\n    timeRange?: number;\n    limit?: number;\n  }): CapturedError[] {\n    let errors = Array.from(this.errors.values());\n    \n    if (filters) {\n      if (filters.category) {\n        errors = errors.filter(e => e.category === filters.category);\n      }\n      if (filters.severity) {\n        errors = errors.filter(e => e.severity === filters.severity);\n      }\n      if (filters.resolved !== undefined) {\n        errors = errors.filter(e => e.resolved === filters.resolved);\n      }\n      if (filters.timeRange) {\n        const cutoff = Date.now() - filters.timeRange;\n        errors = errors.filter(e => e.timestamp >= cutoff);\n      }\n    }\n    \n    errors.sort((a, b) => b.lastOccurred - a.lastOccurred);\n    \n    if (filters?.limit) {\n      errors = errors.slice(0, filters.limit);\n    }\n    \n    return errors;\n  }\n\n  public getError(id: string): CapturedError | undefined {\n    return this.errors.get(id);\n  }\n\n  public markResolved(id: string): void {\n    const error = this.errors.get(id);\n    if (error) {\n      error.resolved = true;\n      this.addBreadcrumb('system', `Error marked as resolved: ${error.message}`, 'info', {\n        errorId: id\n      });\n    }\n  }\n\n  public exportData(): string {\n    return JSON.stringify({\n      errors: Array.from(this.errors.entries()),\n      breadcrumbs: this.breadcrumbs,\n      sessionId: this.sessionId,\n      recoveryActions: Array.from(this.recoveryActions.entries()),\n      exportedAt: Date.now()\n    }, null, 2);\n  }\n\n  public dispose(): void {\n    this.stop();\n    this.observers.length = 0;\n    this.errors.clear();\n    this.breadcrumbs.length = 0;\n    this.recoveryActions.clear();\n  }\n}\n\nexport default ErrorMonitor;"