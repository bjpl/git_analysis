/**
 * Response Time Performance Test Suite
 * Tests for UI response time measurements and latency analysis
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';

describe('Response Time Tests', () => {
    let responseTracker;
    let interactionSystem;
    let latencyMeasurements;

    beforeEach(() => {
        latencyMeasurements = [];
        
        responseTracker = {
            interactions: new Map(),
            measurements: [],
            thresholds: {
                excellent: 100,    // < 100ms excellent
                good: 300,         // < 300ms good  
                acceptable: 1000,  // < 1000ms acceptable
                poor: 3000        // < 3000ms poor (anything above is critical)
            },
            
            startInteraction: function(interactionId, type) {\n                const interaction = {\n                    id: interactionId,\n                    type: type,\n                    startTime: performance.now(),\n                    endTime: null,\n                    duration: null,\n                    phases: [],\n                    metadata: {}\n                };\n                \n                this.interactions.set(interactionId, interaction);\n                return interaction;\n            },\n            \n            addPhase: function(interactionId, phaseName) {\n                const interaction = this.interactions.get(interactionId);\n                if (interaction) {\n                    const currentTime = performance.now();\n                    const phase = {\n                        name: phaseName,\n                        timestamp: currentTime,\n                        duration: currentTime - (interaction.phases.length > 0 \n                            ? interaction.phases[interaction.phases.length - 1].timestamp \n                            : interaction.startTime)\n                    };\n                    \n                    interaction.phases.push(phase);\n                }\n            },\n            \n            endInteraction: function(interactionId, metadata = {}) {\n                const interaction = this.interactions.get(interactionId);\n                if (interaction) {\n                    interaction.endTime = performance.now();\n                    interaction.duration = interaction.endTime - interaction.startTime;\n                    interaction.metadata = { ...interaction.metadata, ...metadata };\n                    \n                    this.measurements.push({\n                        type: interaction.type,\n                        duration: interaction.duration,\n                        phases: interaction.phases.slice(),\n                        timestamp: Date.now(),\n                        metadata: interaction.metadata\n                    });\n                    \n                    latencyMeasurements.push(interaction.duration);\n                    return interaction.duration;\n                }\n                return null;\n            },\n            \n            categorizeResponse: function(duration) {\n                if (duration < this.thresholds.excellent) return 'excellent';\n                if (duration < this.thresholds.good) return 'good';\n                if (duration < this.thresholds.acceptable) return 'acceptable';\n                if (duration < this.thresholds.poor) return 'poor';\n                return 'critical';\n            },\n            \n            getStatistics: function(interactionType = null) {\n                let measurements = this.measurements;\n                if (interactionType) {\n                    measurements = measurements.filter(m => m.type === interactionType);\n                }\n                \n                if (measurements.length === 0) return null;\n                \n                const durations = measurements.map(m => m.duration).sort((a, b) => a - b);\n                const totalDuration = durations.reduce((sum, d) => sum + d, 0);\n                \n                return {\n                    count: measurements.length,\n                    min: durations[0],\n                    max: durations[durations.length - 1],\n                    mean: totalDuration / measurements.length,\n                    median: durations[Math.floor(durations.length / 2)],\n                    p95: durations[Math.floor(durations.length * 0.95)],\n                    p99: durations[Math.floor(durations.length * 0.99)],\n                    \n                    distribution: {\n                        excellent: measurements.filter(m => this.categorizeResponse(m.duration) === 'excellent').length,\n                        good: measurements.filter(m => this.categorizeResponse(m.duration) === 'good').length,\n                        acceptable: measurements.filter(m => this.categorizeResponse(m.duration) === 'acceptable').length,\n                        poor: measurements.filter(m => this.categorizeResponse(m.duration) === 'poor').length,\n                        critical: measurements.filter(m => this.categorizeResponse(m.duration) === 'critical').length\n                    }\n                };\n            },\n            \n            getPerformanceReport: function() {\n                const overall = this.getStatistics();\n                if (!overall) return null;\n                \n                const byType = {};\n                const types = [...new Set(this.measurements.map(m => m.type))];\n                \n                types.forEach(type => {\n                    byType[type] = this.getStatistics(type);\n                });\n                \n                return {\n                    overall,\n                    byType,\n                    totalInteractions: this.measurements.length,\n                    averageResponseTime: overall.mean,\n                    responseTimeGrade: this.getOverallGrade(overall)\n                };\n            },\n            \n            getOverallGrade: function(stats) {\n                const total = stats.count;\n                const excellentPercent = (stats.distribution.excellent / total) * 100;\n                const goodPercent = (stats.distribution.good / total) * 100;\n                const acceptablePercent = (stats.distribution.acceptable / total) * 100;\n                \n                if (excellentPercent >= 80) return 'A+';\n                if (excellentPercent + goodPercent >= 80) return 'A';\n                if (excellentPercent + goodPercent >= 60) return 'B';\n                if (excellentPercent + goodPercent + acceptablePercent >= 80) return 'C';\n                return 'F';\n            },\n            \n            detectPerformanceRegression: function(previousStats) {\n                const currentStats = this.getStatistics();\n                if (!currentStats || !previousStats) return null;\n                \n                const regressions = [];\n                \n                // Check for mean response time regression (>20% increase)\n                const meanIncrease = ((currentStats.mean - previousStats.mean) / previousStats.mean) * 100;\n                if (meanIncrease > 20) {\n                    regressions.push({\n                        type: 'mean_response_time',\n                        previousValue: previousStats.mean,\n                        currentValue: currentStats.mean,\n                        percentageIncrease: meanIncrease\n                    });\n                }\n                \n                // Check for P95 regression (>30% increase)\n                const p95Increase = ((currentStats.p95 - previousStats.p95) / previousStats.p95) * 100;\n                if (p95Increase > 30) {\n                    regressions.push({\n                        type: 'p95_response_time',\n                        previousValue: previousStats.p95,\n                        currentValue: currentStats.p95,\n                        percentageIncrease: p95Increase\n                    });\n                }\n                \n                return {\n                    hasRegression: regressions.length > 0,\n                    regressions,\n                    severity: regressions.length > 1 ? 'high' : regressions.length > 0 ? 'medium' : 'low'\n                };\n            },\n            \n            clear: function() {\n                this.interactions.clear();\n                this.measurements = [];\n                latencyMeasurements = [];\n            }\n        };\n        \n        interactionSystem = {\n            state: {\n                isProcessing: false,\n                currentMenu: 'main',\n                loadedData: new Map(),\n                renderQueue: []\n            },\n            \n            handleMenuNavigation: async function(direction) {\n                const interactionId = `nav_${Date.now()}`;\n                responseTracker.startInteraction(interactionId, 'navigation');\n                \n                // Simulate input processing phase\n                responseTracker.addPhase(interactionId, 'input_processing');\n                await this.simulateProcessing(5, 15);\n                \n                // Simulate state update phase\n                responseTracker.addPhase(interactionId, 'state_update');\n                this.state.currentMenu = direction;\n                await this.simulateProcessing(2, 8);\n                \n                // Simulate render phase\n                responseTracker.addPhase(interactionId, 'render');\n                await this.simulateProcessing(10, 30);\n                \n                return responseTracker.endInteraction(interactionId, { direction });\n            },\n            \n            handleMenuSelection: async function(itemId) {\n                const interactionId = `select_${Date.now()}`;\n                responseTracker.startInteraction(interactionId, 'selection');\n                \n                responseTracker.addPhase(interactionId, 'validation');\n                await this.simulateProcessing(1, 5);\n                \n                responseTracker.addPhase(interactionId, 'data_fetch');\n                await this.simulateDataFetch(itemId);\n                \n                responseTracker.addPhase(interactionId, 'render');\n                await this.simulateProcessing(15, 40);\n                \n                return responseTracker.endInteraction(interactionId, { itemId });\n            },\n            \n            handleFormSubmission: async function(formData) {\n                const interactionId = `form_${Date.now()}`;\n                responseTracker.startInteraction(interactionId, 'form_submission');\n                \n                responseTracker.addPhase(interactionId, 'validation');\n                await this.simulateProcessing(5, 15);\n                \n                if (formData.requiresNetworkCall) {\n                    responseTracker.addPhase(interactionId, 'network_request');\n                    await this.simulateNetworkRequest();\n                }\n                \n                responseTracker.addPhase(interactionId, 'state_update');\n                await this.simulateProcessing(3, 10);\n                \n                responseTracker.addPhase(interactionId, 'render');\n                await this.simulateProcessing(8, 25);\n                \n                return responseTracker.endInteraction(interactionId, { \n                    formSize: Object.keys(formData).length,\n                    hasNetworkCall: formData.requiresNetworkCall \n                });\n            },\n            \n            handleSearch: async function(query) {\n                const interactionId = `search_${Date.now()}`;\n                responseTracker.startInteraction(interactionId, 'search');\n                \n                responseTracker.addPhase(interactionId, 'query_processing');\n                await this.simulateProcessing(2, 8);\n                \n                responseTracker.addPhase(interactionId, 'search_execution');\n                const resultCount = await this.simulateSearch(query);\n                \n                responseTracker.addPhase(interactionId, 'result_rendering');\n                await this.simulateProcessing(resultCount * 2, resultCount * 5);\n                \n                return responseTracker.endInteraction(interactionId, { \n                    queryLength: query.length,\n                    resultCount \n                });\n            },\n            \n            handleDataRefresh: async function() {\n                const interactionId = `refresh_${Date.now()}`;\n                responseTracker.startInteraction(interactionId, 'data_refresh');\n                \n                responseTracker.addPhase(interactionId, 'cache_clear');\n                this.state.loadedData.clear();\n                await this.simulateProcessing(1, 3);\n                \n                responseTracker.addPhase(interactionId, 'data_fetch');\n                await this.simulateNetworkRequest();\n                \n                responseTracker.addPhase(interactionId, 'full_render');\n                await this.simulateProcessing(20, 60);\n                \n                return responseTracker.endInteraction(interactionId, { \n                    dataSize: this.state.loadedData.size \n                });\n            },\n            \n            simulateProcessing: async function(minMs, maxMs) {\n                const delay = Math.random() * (maxMs - minMs) + minMs;\n                if (delay > 1) {\n                    await new Promise(resolve => setTimeout(resolve, delay));\n                }\n            },\n            \n            simulateDataFetch: async function(itemId) {\n                if (this.state.loadedData.has(itemId)) {\n                    // Cache hit - faster response\n                    await this.simulateProcessing(1, 5);\n                } else {\n                    // Cache miss - slower response\n                    await this.simulateProcessing(20, 80);\n                    this.state.loadedData.set(itemId, { loaded: true, timestamp: Date.now() });\n                }\n            },\n            \n            simulateNetworkRequest: async function() {\n                // Simulate network latency with variance\n                const baseLatency = 100;\n                const variance = Math.random() * 200; // 0-200ms variance\n                const networkJitter = (Math.random() - 0.5) * 50; // Â±25ms jitter\n                \n                const totalDelay = baseLatency + variance + networkJitter;\n                await this.simulateProcessing(totalDelay, totalDelay + 10);\n            },\n            \n            simulateSearch: async function(query) {\n                const baseTime = Math.max(10, query.length * 2);\n                const resultCount = Math.min(100, Math.max(0, 50 - query.length * 2));\n                \n                await this.simulateProcessing(baseTime, baseTime + resultCount);\n                return resultCount;\n            },\n            \n            runBenchmarkSuite: async function(iterations = 50) {\n                const results = {\n                    navigation: [],\n                    selection: [],\n                    form_submission: [],\n                    search: [],\n                    data_refresh: []\n                };\n                \n                for (let i = 0; i < iterations; i++) {\n                    // Navigation benchmark\n                    const navTime = await this.handleMenuNavigation('down');\n                    results.navigation.push(navTime);\n                    \n                    // Selection benchmark\n                    const selTime = await this.handleMenuSelection(`item_${i}`);\n                    results.selection.push(selTime);\n                    \n                    // Form submission benchmark (every 5th iteration)\n                    if (i % 5 === 0) {\n                        const formTime = await this.handleFormSubmission({ \n                            name: 'test', \n                            requiresNetworkCall: i % 10 === 0 \n                        });\n                        results.form_submission.push(formTime);\n                    }\n                    \n                    // Search benchmark (every 3rd iteration)\n                    if (i % 3 === 0) {\n                        const searchTime = await this.handleSearch(`query ${i}`);\n                        results.search.push(searchTime);\n                    }\n                    \n                    // Data refresh benchmark (every 10th iteration)\n                    if (i % 10 === 0) {\n                        const refreshTime = await this.handleDataRefresh();\n                        results.data_refresh.push(refreshTime);\n                    }\n                }\n                \n                return results;\n            }\n        };\n    });\n    \n    describe('Basic Response Time Measurements', () => {\n        test('should measure menu navigation response time', async () => {\n            const responseTime = await interactionSystem.handleMenuNavigation('down');\n            \n            expect(responseTime).toBeGreaterThan(0);\n            expect(responseTime).toBeLessThan(100); // Should be under 100ms for good UX\n            expect(responseTracker.categorizeResponse(responseTime)).toMatch(/excellent|good/);\n        });\n\n        test('should measure menu selection response time', async () => {\n            const responseTime = await interactionSystem.handleMenuSelection('arrays');\n            \n            expect(responseTime).toBeGreaterThan(0);\n            expect(responseTime).toBeLessThan(200); // Should be under 200ms for selections\n        });\n\n        test('should measure form submission response time', async () => {\n            const formData = {\n                username: 'testuser',\n                difficulty: 'intermediate',\n                requiresNetworkCall: false\n            };\n            \n            const responseTime = await interactionSystem.handleFormSubmission(formData);\n            \n            expect(responseTime).toBeGreaterThan(0);\n            expect(responseTime).toBeLessThan(300); // Local form processing should be quick\n        });\n\n        test('should measure search response time', async () => {\n            const responseTime = await interactionSystem.handleSearch('array sorting');\n            \n            expect(responseTime).toBeGreaterThan(0);\n            expect(responseTime).toBeLessThan(500); // Search should be reasonably fast\n            \n            const measurement = responseTracker.measurements[responseTracker.measurements.length - 1];\n            expect(measurement.metadata.queryLength).toBe(13);\n        });\n\n        test('should measure data refresh response time', async () => {\n            const responseTime = await interactionSystem.handleDataRefresh();\n            \n            expect(responseTime).toBeGreaterThan(100); // Should include network time\n            expect(responseTime).toBeLessThan(1000); // But not excessive\n        });\n    });\n    \n    describe('Response Time Categorization', () => {\n        test('should categorize response times correctly', () => {\n            expect(responseTracker.categorizeResponse(50)).toBe('excellent');\n            expect(responseTracker.categorizeResponse(150)).toBe('good');\n            expect(responseTracker.categorizeResponse(500)).toBe('acceptable');\n            expect(responseTracker.categorizeResponse(2000)).toBe('poor');\n            expect(responseTracker.categorizeResponse(4000)).toBe('critical');\n        });\n\n        test('should track response time distribution', async () => {\n            // Generate various response times\n            await interactionSystem.handleMenuNavigation('up'); // Should be excellent\n            await interactionSystem.handleMenuSelection('item1'); // Should be good\n            await interactionSystem.handleFormSubmission({ requiresNetworkCall: true }); // Might be acceptable\n            \n            const stats = responseTracker.getStatistics();\n            \n            expect(stats.distribution.excellent).toBeGreaterThanOrEqual(0);\n            expect(stats.distribution.good).toBeGreaterThanOrEqual(0);\n            expect(stats.distribution.acceptable).toBeGreaterThanOrEqual(0);\n            expect(stats.count).toBe(3);\n        });\n    });\n    \n    describe('Performance Statistics', () => {\n        test('should provide comprehensive statistics', async () => {\n            // Generate multiple interactions\n            for (let i = 0; i < 10; i++) {\n                await interactionSystem.handleMenuNavigation(i % 2 === 0 ? 'up' : 'down');\n            }\n            \n            const stats = responseTracker.getStatistics('navigation');\n            \n            expect(stats.count).toBe(10);\n            expect(stats.min).toBeGreaterThan(0);\n            expect(stats.max).toBeGreaterThan(stats.min);\n            expect(stats.mean).toBeGreaterThan(0);\n            expect(stats.median).toBeGreaterThan(0);\n            expect(stats.p95).toBeGreaterThan(stats.median);\n        });\n\n        test('should provide performance report with grades', async () => {\n            // Generate mixed performance interactions\n            for (let i = 0; i < 20; i++) {\n                if (i < 15) {\n                    await interactionSystem.handleMenuNavigation('up'); // Fast operations\n                } else {\n                    await interactionSystem.handleFormSubmission({ requiresNetworkCall: true }); // Slower operations\n                }\n            }\n            \n            const report = responseTracker.getPerformanceReport();\n            \n            expect(report).toBeDefined();\n            expect(report.overall).toBeDefined();\n            expect(report.byType.navigation).toBeDefined();\n            expect(report.byType.form_submission).toBeDefined();\n            expect(report.responseTimeGrade).toMatch(/A\\+|A|B|C|F/);\n            expect(report.totalInteractions).toBe(20);\n        });\n    });\n    \n    describe('Phase-based Performance Analysis', () => {\n        test('should track interaction phases', async () => {\n            await interactionSystem.handleMenuSelection('detailed-item');\n            \n            const interaction = responseTracker.measurements[responseTracker.measurements.length - 1];\n            \n            expect(interaction.phases).toBeDefined();\n            expect(interaction.phases.length).toBeGreaterThan(0);\n            \n            // Should have validation, data_fetch, and render phases\n            const phaseNames = interaction.phases.map(p => p.name);\n            expect(phaseNames).toContain('validation');\n            expect(phaseNames).toContain('data_fetch');\n            expect(phaseNames).toContain('render');\n        });\n\n        test('should identify slow phases', async () => {\n            await interactionSystem.handleFormSubmission({ \n                data: 'large form data',\n                requiresNetworkCall: true \n            });\n            \n            const interaction = responseTracker.measurements[responseTracker.measurements.length - 1];\n            const phases = interaction.phases;\n            \n            // Find the slowest phase\n            const slowestPhase = phases.reduce((slowest, phase) => \n                phase.duration > slowest.duration ? phase : slowest\n            );\n            \n            expect(slowestPhase).toBeDefined();\n            expect(slowestPhase.duration).toBeGreaterThan(0);\n            \n            // Network phase should typically be slowest for network operations\n            if (phases.some(p => p.name === 'network_request')) {\n                const networkPhase = phases.find(p => p.name === 'network_request');\n                expect(networkPhase.duration).toBeGreaterThan(50); // Network should take meaningful time\n            }\n        });\n    });\n    \n    describe('Performance Regression Detection', () => {\n        test('should detect mean response time regression', async () => {\n            // Establish baseline\n            for (let i = 0; i < 20; i++) {\n                await interactionSystem.handleMenuNavigation('up');\n            }\n            \n            const baselineStats = responseTracker.getStatistics();\n            responseTracker.clear();\n            \n            // Simulate degraded performance\n            const originalSimulateProcessing = interactionSystem.simulateProcessing;\n            interactionSystem.simulateProcessing = async function(minMs, maxMs) {\n                return originalSimulateProcessing.call(this, minMs * 2, maxMs * 2); // 2x slower\n            };\n            \n            for (let i = 0; i < 20; i++) {\n                await interactionSystem.handleMenuNavigation('up');\n            }\n            \n            const regressionAnalysis = responseTracker.detectPerformanceRegression(baselineStats);\n            \n            expect(regressionAnalysis.hasRegression).toBe(true);\n            expect(regressionAnalysis.regressions.length).toBeGreaterThan(0);\n            expect(regressionAnalysis.severity).toMatch(/medium|high/);\n            \n            // Restore original function\n            interactionSystem.simulateProcessing = originalSimulateProcessing;\n        });\n\n        test('should not flag minor variations as regressions', async () => {\n            // Generate baseline data\n            for (let i = 0; i < 50; i++) {\n                await interactionSystem.handleMenuNavigation('up');\n            }\n            \n            const baselineStats = responseTracker.getStatistics();\n            responseTracker.clear();\n            \n            // Generate similar performance data (minor variation)\n            for (let i = 0; i < 50; i++) {\n                await interactionSystem.handleMenuNavigation('up');\n            }\n            \n            const regressionAnalysis = responseTracker.detectPerformanceRegression(baselineStats);\n            \n            expect(regressionAnalysis.hasRegression).toBe(false);\n            expect(regressionAnalysis.severity).toBe('low');\n        });\n    });\n    \n    describe('Load Testing Response Times', () => {\n        test('should maintain reasonable response times under load', async () => {\n            const results = await interactionSystem.runBenchmarkSuite(25);\n            \n            // Check navigation performance\n            const navStats = this.calculateStats(results.navigation);\n            expect(navStats.mean).toBeLessThan(100); // Average navigation under 100ms\n            expect(navStats.p95).toBeLessThan(150); // 95th percentile under 150ms\n            \n            // Check selection performance  \n            const selStats = this.calculateStats(results.selection);\n            expect(selStats.mean).toBeLessThan(200); // Average selection under 200ms\n            expect(selStats.p95).toBeLessThan(300); // 95th percentile under 300ms\n        });\n\n        test('should show performance consistency over time', async () => {\n            const batchSize = 10;\n            const batches = 5;\n            const batchResults = [];\n            \n            for (let batch = 0; batch < batches; batch++) {\n                const batchStart = responseTracker.measurements.length;\n                \n                for (let i = 0; i < batchSize; i++) {\n                    await interactionSystem.handleMenuNavigation('up');\n                }\n                \n                const batchMeasurements = responseTracker.measurements.slice(batchStart);\n                const batchAverage = batchMeasurements.reduce((sum, m) => sum + m.duration, 0) / batchSize;\n                batchResults.push(batchAverage);\n            }\n            \n            // Check consistency (coefficient of variation should be low)\n            const overallMean = batchResults.reduce((sum, avg) => sum + avg, 0) / batches;\n            const variance = batchResults.reduce((sum, avg) => sum + Math.pow(avg - overallMean, 2), 0) / batches;\n            const standardDeviation = Math.sqrt(variance);\n            const coefficientOfVariation = standardDeviation / overallMean;\n            \n            expect(coefficientOfVariation).toBeLessThan(0.3); // CV should be less than 30%\n        });\n    });\n    \n    describe('Caching Impact on Response Times', () => {\n        test('should show improved response times with caching', async () => {\n            const itemId = 'cached-test-item';\n            \n            // First access (cache miss)\n            const firstResponse = await interactionSystem.handleMenuSelection(itemId);\n            \n            // Second access (cache hit)\n            const secondResponse = await interactionSystem.handleMenuSelection(itemId);\n            \n            // Cache hit should be significantly faster\n            expect(secondResponse).toBeLessThan(firstResponse * 0.5); // At least 50% faster\n        });\n\n        test('should track cache hit rate impact on performance', async () => {\n            const items = ['item1', 'item2', 'item3'];\n            const responseTimes = [];\n            \n            // Generate cache misses and hits\n            for (let round = 0; round < 3; round++) {\n                for (const item of items) {\n                    const responseTime = await interactionSystem.handleMenuSelection(item);\n                    responseTimes.push({\n                        item,\n                        round,\n                        responseTime,\n                        isCacheHit: round > 0 // First round is cache miss\n                    });\n                }\n            }\n            \n            // Calculate average response times for cache hits vs misses\n            const cacheMisses = responseTimes.filter(r => !r.isCacheHit);\n            const cacheHits = responseTimes.filter(r => r.isCacheHit);\n            \n            const avgCacheMiss = cacheMisses.reduce((sum, r) => sum + r.responseTime, 0) / cacheMisses.length;\n            const avgCacheHit = cacheHits.reduce((sum, r) => sum + r.responseTime, 0) / cacheHits.length;\n            \n            expect(avgCacheHit).toBeLessThan(avgCacheMiss);\n            expect(avgCacheHit / avgCacheMiss).toBeLessThan(0.8); // Cache hits should be 20%+ faster\n        });\n    });\n    \n    // Helper method for calculating statistics\n    describe.skip('Helper Methods', () => {\n        beforeEach(() => {\n            this.calculateStats = function(values) {\n                const sorted = values.slice().sort((a, b) => a - b);\n                const sum = sorted.reduce((a, b) => a + b, 0);\n                \n                return {\n                    count: sorted.length,\n                    min: sorted[0],\n                    max: sorted[sorted.length - 1],\n                    mean: sum / sorted.length,\n                    median: sorted[Math.floor(sorted.length / 2)],\n                    p95: sorted[Math.floor(sorted.length * 0.95)],\n                    p99: sorted[Math.floor(sorted.length * 0.99)]\n                };\n            };\n        });\n    });\n});"