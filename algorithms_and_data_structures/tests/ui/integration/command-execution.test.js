/**
 * Command Execution Integration Tests
 * Tests for command processing and execution workflows
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';

describe('Command Execution Integration Tests', () => {
    let commandSystem;
    let executionLog;
    let mockFileSystem;

    beforeEach(() => {
        executionLog = [];
        
        mockFileSystem = {
            files: new Map(),
            write: jest.fn(function(path, content) {
                this.files.set(path, content);
                return Promise.resolve();
            }),
            read: jest.fn(function(path) {
                return Promise.resolve(this.files.get(path) || null);
            }),
            exists: jest.fn(function(path) {
                return Promise.resolve(this.files.has(path));
            }),
            delete: jest.fn(function(path) {
                const existed = this.files.has(path);
                this.files.delete(path);
                return Promise.resolve(existed);
            })\n        };\n\n        commandSystem = {\n            state: {\n                currentLesson: null,\n                progress: new Map(),\n                settings: {\n                    difficulty: 'beginner',\n                    showHints: true,\n                    autoSave: true\n                },\n                history: [],\n                isExecuting: false,\n                lastCommand: null,\n                commandQueue: []\n            },\n            commands: {\n                start: {\n                    name: 'start',\n                    description: 'Start a lesson',\n                    usage: 'start <lesson-name>',\n                    requiresArgs: true,\n                    execute: async function(args, context) {\n                        const lessonName = args[0];\n                        executionLog.push({ command: 'start', args, timestamp: Date.now() });\n                        \n                        if (!lessonName) {\n                            throw new Error('Lesson name is required');\n                        }\n                        \n                        context.state.currentLesson = lessonName;\n                        context.state.progress.set(lessonName, { started: true, completed: false, score: 0 });\n                        \n                        return {\n                            success: true,\n                            message: `Started lesson: ${lessonName}`,\n                            data: { lesson: lessonName }\n                        };\n                    }\n                },\n                complete: {\n                    name: 'complete',\n                    description: 'Mark current lesson as complete',\n                    usage: 'complete [score]',\n                    execute: async function(args, context) {\n                        executionLog.push({ command: 'complete', args, timestamp: Date.now() });\n                        \n                        if (!context.state.currentLesson) {\n                            throw new Error('No active lesson to complete');\n                        }\n                        \n                        const score = args[0] ? parseInt(args[0]) : 100;\n                        const progress = context.state.progress.get(context.state.currentLesson);\n                        \n                        if (progress) {\n                            progress.completed = true;\n                            progress.score = Math.max(progress.score, score);\n                            progress.completedAt = new Date().toISOString();\n                        }\n                        \n                        // Auto-save progress if enabled\n                        if (context.state.settings.autoSave) {\n                            await context.saveProgress();\n                        }\n                        \n                        return {\n                            success: true,\n                            message: `Completed lesson: ${context.state.currentLesson} (Score: ${score})`,\n                            data: { lesson: context.state.currentLesson, score }\n                        };\n                    }\n                },\n                progress: {\n                    name: 'progress',\n                    description: 'View learning progress',\n                    usage: 'progress [lesson-name]',\n                    execute: async function(args, context) {\n                        executionLog.push({ command: 'progress', args, timestamp: Date.now() });\n                        \n                        if (args[0]) {\n                            const lessonProgress = context.state.progress.get(args[0]);\n                            return {\n                                success: true,\n                                message: lessonProgress ? 'Lesson progress found' : 'Lesson not started',\n                                data: { lesson: args[0], progress: lessonProgress }\n                            };\n                        } else {\n                            const allProgress = Object.fromEntries(context.state.progress);\n                            return {\n                                success: true,\n                                message: `Found progress for ${context.state.progress.size} lessons`,\n                                data: { progress: allProgress }\n                            };\n                        }\n                    }\n                },\n                set: {\n                    name: 'set',\n                    description: 'Update settings',\n                    usage: 'set <setting> <value>',\n                    requiresArgs: true,\n                    execute: async function(args, context) {\n                        executionLog.push({ command: 'set', args, timestamp: Date.now() });\n                        \n                        const [setting, value] = args;\n                        if (!setting || value === undefined) {\n                            throw new Error('Setting name and value are required');\n                        }\n                        \n                        const validSettings = ['difficulty', 'showHints', 'autoSave'];\n                        if (!validSettings.includes(setting)) {\n                            throw new Error(`Invalid setting: ${setting}`);\n                        }\n                        \n                        // Type conversion\n                        let convertedValue = value;\n                        if (setting === 'showHints' || setting === 'autoSave') {\n                            convertedValue = value === 'true' || value === '1';\n                        }\n                        \n                        context.state.settings[setting] = convertedValue;\n                        \n                        return {\n                            success: true,\n                            message: `Updated ${setting} to ${convertedValue}`,\n                            data: { setting, value: convertedValue }\n                        };\n                    }\n                },\n                save: {\n                    name: 'save',\n                    description: 'Save progress to file',\n                    usage: 'save [filename]',\n                    execute: async function(args, context) {\n                        executionLog.push({ command: 'save', args, timestamp: Date.now() });\n                        \n                        const filename = args[0] || 'progress.json';\n                        const data = {\n                            progress: Object.fromEntries(context.state.progress),\n                            settings: context.state.settings,\n                            savedAt: new Date().toISOString()\n                        };\n                        \n                        await mockFileSystem.write(filename, JSON.stringify(data, null, 2));\n                        \n                        return {\n                            success: true,\n                            message: `Progress saved to ${filename}`,\n                            data: { filename, itemCount: context.state.progress.size }\n                        };\n                    }\n                },\n                load: {\n                    name: 'load',\n                    description: 'Load progress from file',\n                    usage: 'load [filename]',\n                    execute: async function(args, context) {\n                        executionLog.push({ command: 'load', args, timestamp: Date.now() });\n                        \n                        const filename = args[0] || 'progress.json';\n                        const content = await mockFileSystem.read(filename);\n                        \n                        if (!content) {\n                            throw new Error(`File not found: ${filename}`);\n                        }\n                        \n                        const data = JSON.parse(content);\n                        context.state.progress = new Map(Object.entries(data.progress || {}));\n                        context.state.settings = { ...context.state.settings, ...data.settings };\n                        \n                        return {\n                            success: true,\n                            message: `Progress loaded from ${filename}`,\n                            data: { filename, itemCount: context.state.progress.size }\n                        };\n                    }\n                },\n                reset: {\n                    name: 'reset',\n                    description: 'Reset progress',\n                    usage: 'reset [lesson-name|all]',\n                    execute: async function(args, context) {\n                        executionLog.push({ command: 'reset', args, timestamp: Date.now() });\n                        \n                        const target = args[0] || 'current';\n                        \n                        if (target === 'all') {\n                            const count = context.state.progress.size;\n                            context.state.progress.clear();\n                            context.state.currentLesson = null;\n                            return {\n                                success: true,\n                                message: `Reset progress for ${count} lessons`,\n                                data: { resetCount: count }\n                            };\n                        } else if (target === 'current' && context.state.currentLesson) {\n                            context.state.progress.delete(context.state.currentLesson);\n                            const lesson = context.state.currentLesson;\n                            context.state.currentLesson = null;\n                            return {\n                                success: true,\n                                message: `Reset progress for lesson: ${lesson}`,\n                                data: { lesson }\n                            };\n                        } else if (context.state.progress.has(target)) {\n                            context.state.progress.delete(target);\n                            return {\n                                success: true,\n                                message: `Reset progress for lesson: ${target}`,\n                                data: { lesson: target }\n                            };\n                        } else {\n                            throw new Error(`Lesson not found: ${target}`);\n                        }\n                    }\n                },\n                help: {\n                    name: 'help',\n                    description: 'Show help information',\n                    usage: 'help [command-name]',\n                    execute: async function(args, context) {\n                        executionLog.push({ command: 'help', args, timestamp: Date.now() });\n                        \n                        if (args[0]) {\n                            const command = context.commands[args[0]];\n                            if (!command) {\n                                throw new Error(`Unknown command: ${args[0]}`);\n                            }\n                            return {\n                                success: true,\n                                message: `Help for ${command.name}`,\n                                data: {\n                                    name: command.name,\n                                    description: command.description,\n                                    usage: command.usage\n                                }\n                            };\n                        } else {\n                            const commands = Object.values(context.commands).map(cmd => ({\n                                name: cmd.name,\n                                description: cmd.description,\n                                usage: cmd.usage\n                            }));\n                            return {\n                                success: true,\n                                message: `Available commands (${commands.length})`,\n                                data: { commands }\n                            };\n                        }\n                    }\n                }\n            },\n            execute: async function(commandLine) {\n                if (this.state.isExecuting) {\n                    this.state.commandQueue.push(commandLine);\n                    return { success: true, message: 'Command queued', queued: true };\n                }\n                \n                this.state.isExecuting = true;\n                \n                try {\n                    const parts = commandLine.trim().split(/\\s+/);\n                    const commandName = parts[0];\n                    const args = parts.slice(1);\n                    \n                    const command = this.commands[commandName];\n                    if (!command) {\n                        throw new Error(`Unknown command: ${commandName}`);\n                    }\n                    \n                    if (command.requiresArgs && args.length === 0) {\n                        throw new Error(`Command '${commandName}' requires arguments. Usage: ${command.usage}`);\n                    }\n                    \n                    this.state.history.push({\n                        command: commandLine,\n                        timestamp: Date.now(),\n                        status: 'executing'\n                    });\n                    \n                    const result = await command.execute(args, this);\n                    \n                    // Update history with result\n                    this.state.history[this.state.history.length - 1].status = 'completed';\n                    this.state.history[this.state.history.length - 1].result = result;\n                    this.state.lastCommand = { command: commandName, args, result };\n                    \n                    return result;\n                    \n                } catch (error) {\n                    // Update history with error\n                    if (this.state.history.length > 0) {\n                        this.state.history[this.state.history.length - 1].status = 'error';\n                        this.state.history[this.state.history.length - 1].error = error.message;\n                    }\n                    \n                    return {\n                        success: false,\n                        message: error.message,\n                        error: error.name\n                    };\n                } finally {\n                    this.state.isExecuting = false;\n                    \n                    // Process queued commands\n                    if (this.state.commandQueue.length > 0) {\n                        const nextCommand = this.state.commandQueue.shift();\n                        setTimeout(() => this.execute(nextCommand), 0);\n                    }\n                }\n            },\n            saveProgress: async function() {\n                return this.execute('save');\n            },\n            getCommandHistory: function() {\n                return this.state.history.slice();\n            },\n            clearHistory: function() {\n                this.state.history = [];\n            }\n        };\n    });\n\n    describe('Basic Command Execution', () => {\n        test('should execute start command successfully', async () => {\n            const result = await commandSystem.execute('start arrays');\n            \n            expect(result.success).toBe(true);\n            expect(result.message).toContain('Started lesson: arrays');\n            expect(commandSystem.state.currentLesson).toBe('arrays');\n            expect(commandSystem.state.progress.has('arrays')).toBe(true);\n        });\n\n        test('should execute complete command successfully', async () => {\n            await commandSystem.execute('start trees');\n            const result = await commandSystem.execute('complete 85');\n            \n            expect(result.success).toBe(true);\n            expect(result.data.score).toBe(85);\n            \n            const progress = commandSystem.state.progress.get('trees');\n            expect(progress.completed).toBe(true);\n            expect(progress.score).toBe(85);\n        });\n\n        test('should execute progress command and return data', async () => {\n            await commandSystem.execute('start sorting');\n            await commandSystem.execute('complete 92');\n            \n            const result = await commandSystem.execute('progress');\n            \n            expect(result.success).toBe(true);\n            expect(result.data.progress).toBeDefined();\n            expect(result.data.progress.sorting).toBeDefined();\n            expect(result.data.progress.sorting.completed).toBe(true);\n        });\n\n        test('should execute help command and return command info', async () => {\n            const result = await commandSystem.execute('help');\n            \n            expect(result.success).toBe(true);\n            expect(result.data.commands).toBeDefined();\n            expect(result.data.commands.length).toBeGreaterThan(0);\n            \n            const helpForStart = await commandSystem.execute('help start');\n            expect(helpForStart.data.name).toBe('start');\n            expect(helpForStart.data.usage).toBeDefined();\n        });\n    });\n\n    describe('Command Validation and Error Handling', () => {\n        test('should handle unknown commands', async () => {\n            const result = await commandSystem.execute('unknown-command');\n            \n            expect(result.success).toBe(false);\n            expect(result.message).toContain('Unknown command: unknown-command');\n        });\n\n        test('should validate required arguments', async () => {\n            const result = await commandSystem.execute('start');\n            \n            expect(result.success).toBe(false);\n            expect(result.message).toContain('requires arguments');\n        });\n\n        test('should handle command execution errors', async () => {\n            const result = await commandSystem.execute('complete');\n            \n            expect(result.success).toBe(false);\n            expect(result.message).toContain('No active lesson');\n        });\n\n        test('should handle invalid settings', async () => {\n            const result = await commandSystem.execute('set invalidSetting value');\n            \n            expect(result.success).toBe(false);\n            expect(result.message).toContain('Invalid setting');\n        });\n\n        test('should handle file operation errors', async () => {\n            const result = await commandSystem.execute('load nonexistent.json');\n            \n            expect(result.success).toBe(false);\n            expect(result.message).toContain('File not found');\n        });\n    });\n\n    describe('Settings Management', () => {\n        test('should update string settings', async () => {\n            const result = await commandSystem.execute('set difficulty advanced');\n            \n            expect(result.success).toBe(true);\n            expect(commandSystem.state.settings.difficulty).toBe('advanced');\n        });\n\n        test('should update boolean settings', async () => {\n            const result1 = await commandSystem.execute('set showHints false');\n            expect(result1.success).toBe(true);\n            expect(commandSystem.state.settings.showHints).toBe(false);\n            \n            const result2 = await commandSystem.execute('set autoSave true');\n            expect(result2.success).toBe(true);\n            expect(commandSystem.state.settings.autoSave).toBe(true);\n        });\n\n        test('should handle boolean conversion from strings', async () => {\n            await commandSystem.execute('set showHints 1');\n            expect(commandSystem.state.settings.showHints).toBe(true);\n            \n            await commandSystem.execute('set showHints 0');\n            expect(commandSystem.state.settings.showHints).toBe(false);\n        });\n    });\n\n    describe('Progress Persistence', () => {\n        test('should save progress to file', async () => {\n            await commandSystem.execute('start graphs');\n            await commandSystem.execute('complete 88');\n            \n            const result = await commandSystem.execute('save test-progress.json');\n            \n            expect(result.success).toBe(true);\n            expect(mockFileSystem.write).toHaveBeenCalledWith(\n                'test-progress.json',\n                expect.stringContaining('graphs')\n            );\n        });\n\n        test('should load progress from file', async () => {\n            // Setup some progress and save it\n            await commandSystem.execute('start dynamic');\n            await commandSystem.execute('complete 95');\n            await commandSystem.execute('save test-load.json');\n            \n            // Clear current progress\n            commandSystem.state.progress.clear();\n            commandSystem.state.currentLesson = null;\n            \n            // Load it back\n            const result = await commandSystem.execute('load test-load.json');\n            \n            expect(result.success).toBe(true);\n            expect(commandSystem.state.progress.has('dynamic')).toBe(true);\n            expect(commandSystem.state.progress.get('dynamic').score).toBe(95);\n        });\n\n        test('should handle auto-save when enabled', async () => {\n            await commandSystem.execute('set autoSave true');\n            await commandSystem.execute('start recursion');\n            await commandSystem.execute('complete 90');\n            \n            // Auto-save should have been triggered\n            expect(mockFileSystem.write).toHaveBeenCalledWith(\n                'progress.json',\n                expect.stringContaining('recursion')\n            );\n        });\n    });\n\n    describe('Progress Reset Operations', () => {\n        test('should reset current lesson progress', async () => {\n            await commandSystem.execute('start searching');\n            await commandSystem.execute('complete 87');\n            \n            const result = await commandSystem.execute('reset current');\n            \n            expect(result.success).toBe(true);\n            expect(commandSystem.state.progress.has('searching')).toBe(false);\n            expect(commandSystem.state.currentLesson).toBeNull();\n        });\n\n        test('should reset specific lesson progress', async () => {\n            await commandSystem.execute('start lesson1');\n            await commandSystem.execute('complete 80');\n            await commandSystem.execute('start lesson2');\n            await commandSystem.execute('complete 75');\n            \n            const result = await commandSystem.execute('reset lesson1');\n            \n            expect(result.success).toBe(true);\n            expect(commandSystem.state.progress.has('lesson1')).toBe(false);\n            expect(commandSystem.state.progress.has('lesson2')).toBe(true);\n        });\n\n        test('should reset all progress', async () => {\n            await commandSystem.execute('start lesson1');\n            await commandSystem.execute('complete 90');\n            await commandSystem.execute('start lesson2');\n            await commandSystem.execute('complete 85');\n            \n            const result = await commandSystem.execute('reset all');\n            \n            expect(result.success).toBe(true);\n            expect(result.data.resetCount).toBe(2);\n            expect(commandSystem.state.progress.size).toBe(0);\n        });\n\n        test('should handle reset of non-existent lesson', async () => {\n            const result = await commandSystem.execute('reset nonexistent');\n            \n            expect(result.success).toBe(false);\n            expect(result.message).toContain('Lesson not found');\n        });\n    });\n\n    describe('Command History and State', () => {\n        test('should maintain command execution history', async () => {\n            await commandSystem.execute('start test-lesson');\n            await commandSystem.execute('complete 100');\n            await commandSystem.execute('progress');\n            \n            const history = commandSystem.getCommandHistory();\n            \n            expect(history).toHaveLength(3);\n            expect(history[0].command).toBe('start test-lesson');\n            expect(history[0].status).toBe('completed');\n            expect(history[1].command).toBe('complete 100');\n            expect(history[2].command).toBe('progress');\n        });\n\n        test('should track command execution errors in history', async () => {\n            await commandSystem.execute('invalid-command');\n            \n            const history = commandSystem.getCommandHistory();\n            const lastEntry = history[history.length - 1];\n            \n            expect(lastEntry.status).toBe('error');\n            expect(lastEntry.error).toBeDefined();\n        });\n\n        test('should clear command history', async () => {\n            await commandSystem.execute('help');\n            await commandSystem.execute('progress');\n            \n            commandSystem.clearHistory();\n            \n            expect(commandSystem.getCommandHistory()).toHaveLength(0);\n        });\n\n        test('should track last successful command', async () => {\n            await commandSystem.execute('start last-test');\n            \n            expect(commandSystem.state.lastCommand).toBeDefined();\n            expect(commandSystem.state.lastCommand.command).toBe('start');\n            expect(commandSystem.state.lastCommand.args).toEqual(['last-test']);\n            expect(commandSystem.state.lastCommand.result.success).toBe(true);\n        });\n    });\n\n    describe('Concurrent Command Execution', () => {\n        test('should queue commands when system is busy', async () => {\n            // Start a command that will take time\n            const promise1 = commandSystem.execute('start concurrent-test-1');\n            const promise2 = commandSystem.execute('start concurrent-test-2');\n            \n            const result1 = await promise1;\n            const result2 = await promise2;\n            \n            expect(result1.success).toBe(true);\n            // Second command should either succeed or be queued\n            expect(result2.success || result2.queued).toBe(true);\n        });\n\n        test('should prevent concurrent execution', async () => {\n            commandSystem.state.isExecuting = true;\n            \n            const result = await commandSystem.execute('help');\n            \n            expect(result.queued).toBe(true);\n            expect(commandSystem.state.commandQueue).toHaveLength(1);\n        });\n    });\n\n    describe('Complex Command Workflows', () => {\n        test('should execute complete learning workflow', async () => {\n            const workflow = [\n                'set difficulty intermediate',\n                'start comprehensive-test',\n                'complete 95',\n                'save workflow-test.json',\n                'progress comprehensive-test'\n            ];\n            \n            const results = [];\n            for (const command of workflow) {\n                results.push(await commandSystem.execute(command));\n            }\n            \n            // All commands should succeed\n            expect(results.every(r => r.success)).toBe(true);\n            \n            // Verify final state\n            expect(commandSystem.state.settings.difficulty).toBe('intermediate');\n            expect(commandSystem.state.progress.get('comprehensive-test').completed).toBe(true);\n            expect(commandSystem.state.progress.get('comprehensive-test').score).toBe(95);\n        });\n\n        test('should handle error recovery in workflows', async () => {\n            await commandSystem.execute('start error-recovery-test');\n            \n            // This should fail\n            const errorResult = await commandSystem.execute('invalid-command');\n            expect(errorResult.success).toBe(false);\n            \n            // This should still work\n            const successResult = await commandSystem.execute('complete 88');\n            expect(successResult.success).toBe(true);\n            \n            // Verify the lesson was still completed despite the error\n            const progress = commandSystem.state.progress.get('error-recovery-test');\n            expect(progress.completed).toBe(true);\n        });\n    });\n});"