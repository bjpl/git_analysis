/**\n * Navigation System Demo\n * Demonstrates navigation patterns, state management, and user flow\n */\n\nimport chalk from 'chalk';\nimport inquirer from 'inquirer';\n\ninterface Screen {\n    id: string;\n    title: string;\n    description?: string;\n    parent?: string;\n    items?: MenuItem[];\n    content?: string;\n    actions?: ScreenAction[];\n}\n\ninterface MenuItem {\n    id: string;\n    label: string;\n    description?: string;\n    screen?: string;\n    action?: string;\n    icon?: string;\n    shortcut?: string;\n    enabled?: boolean;\n}\n\ninterface ScreenAction {\n    id: string;\n    label: string;\n    key: string;\n    description: string;\n}\n\ninterface NavigationState {\n    currentScreen: string;\n    history: string[];\n    breadcrumbs: string[];\n    selectedIndex: number;\n    searchQuery: string;\n    lastAction: string | null;\n}\n\nclass NavigationDemo {\n    private state: NavigationState;\n    private screens: Map<string, Screen>;\n    private isRunning: boolean = true;\n    private analytics: {\n        screenViews: Map<string, number>;\n        navigationActions: string[];\n        sessionStart: number;\n    };\n\n    constructor() {\n        this.state = {\n            currentScreen: 'main',\n            history: [],\n            breadcrumbs: ['Home'],\n            selectedIndex: 0,\n            searchQuery: '',\n            lastAction: null\n        };\n\n        this.analytics = {\n            screenViews: new Map(),\n            navigationActions: [],\n            sessionStart: Date.now()\n        };\n\n        this.initializeScreens();\n    }\n\n    private initializeScreens(): void {\n        this.screens = new Map([\n            ['main', {\n                id: 'main',\n                title: 'Learning Hub',\n                description: 'Choose your learning path in algorithms and data structures',\n                items: [\n                    {\n                        id: 'fundamentals',\n                        label: 'Fundamentals',\n                        description: 'Basic concepts and building blocks',\n                        screen: 'fundamentals',\n                        icon: 'üèóÔ∏è',\n                        shortcut: '1'\n                    },\n                    {\n                        id: 'data-structures',\n                        label: 'Data Structures',\n                        description: 'Arrays, lists, trees, graphs, and more',\n                        screen: 'data-structures',\n                        icon: 'üìä',\n                        shortcut: '2'\n                    },\n                    {\n                        id: 'algorithms',\n                        label: 'Algorithms',\n                        description: 'Sorting, searching, and optimization',\n                        screen: 'algorithms',\n                        icon: '‚öôÔ∏è',\n                        shortcut: '3'\n                    },\n                    {\n                        id: 'practice',\n                        label: 'Practice Problems',\n                        description: 'Apply your knowledge with coding challenges',\n                        screen: 'practice',\n                        icon: 'üí™',\n                        shortcut: '4'\n                    },\n                    {\n                        id: 'analytics',\n                        label: 'Progress Analytics',\n                        description: 'Track your learning progress and performance',\n                        screen: 'analytics',\n                        icon: 'üìà',\n                        shortcut: '5'\n                    },\n                    {\n                        id: 'settings',\n                        label: 'Settings',\n                        description: 'Customize your learning experience',\n                        screen: 'settings',\n                        icon: '‚öôÔ∏è',\n                        shortcut: '6'\n                    }\n                ]\n            }],\n            ['fundamentals', {\n                id: 'fundamentals',\n                title: 'Fundamentals',\n                description: 'Master the building blocks of computer science',\n                parent: 'main',\n                items: [\n                    {\n                        id: 'complexity',\n                        label: 'Time & Space Complexity',\n                        description: 'Big O notation and algorithmic analysis',\n                        screen: 'complexity',\n                        icon: '‚è±Ô∏è'\n                    },\n                    {\n                        id: 'recursion',\n                        label: 'Recursion',\n                        description: 'Recursive thinking and problem solving',\n                        screen: 'recursion',\n                        icon: 'üîÑ'\n                    },\n                    {\n                        id: 'math-foundations',\n                        label: 'Mathematical Foundations',\n                        description: 'Discrete math, logic, and proofs',\n                        screen: 'math-foundations',\n                        icon: 'üßÆ'\n                    },\n                    {\n                        id: 'problem-solving',\n                        label: 'Problem Solving Patterns',\n                        description: 'Common approaches and strategies',\n                        screen: 'problem-solving',\n                        icon: 'üß©'\n                    }\n                ]\n            }],\n            ['data-structures', {\n                id: 'data-structures',\n                title: 'Data Structures',\n                description: 'Learn how to organize and store data efficiently',\n                parent: 'main',\n                items: [\n                    {\n                        id: 'arrays-lists',\n                        label: 'Arrays & Lists',\n                        description: 'Dynamic arrays, linked lists, stacks, queues',\n                        screen: 'arrays-lists',\n                        icon: 'üìù'\n                    },\n                    {\n                        id: 'trees',\n                        label: 'Trees',\n                        description: 'Binary trees, BST, AVL, Red-Black trees',\n                        screen: 'trees',\n                        icon: 'üå≥'\n                    },\n                    {\n                        id: 'graphs',\n                        label: 'Graphs',\n                        description: 'Graph representation and traversal',\n                        screen: 'graphs',\n                        icon: 'üï∏Ô∏è'\n                    },\n                    {\n                        id: 'hashing',\n                        label: 'Hash Tables',\n                        description: 'Hash functions, collision resolution',\n                        screen: 'hashing',\n                        icon: '#Ô∏è‚É£'\n                    },\n                    {\n                        id: 'heaps',\n                        label: 'Heaps & Priority Queues',\n                        description: 'Min/max heaps and priority queue operations',\n                        screen: 'heaps',\n                        icon: '‚õ∞Ô∏è'\n                    }\n                ]\n            }],\n            ['algorithms', {\n                id: 'algorithms',\n                title: 'Algorithms',\n                description: 'Master fundamental algorithmic techniques',\n                parent: 'main',\n                items: [\n                    {\n                        id: 'sorting',\n                        label: 'Sorting Algorithms',\n                        description: 'Bubble, merge, quick, heap, radix sort',\n                        screen: 'sorting',\n                        icon: 'üîÑ'\n                    },\n                    {\n                        id: 'searching',\n                        label: 'Searching Algorithms',\n                        description: 'Linear, binary, and advanced search techniques',\n                        screen: 'searching',\n                        icon: 'üîç'\n                    },\n                    {\n                        id: 'graph-algorithms',\n                        label: 'Graph Algorithms',\n                        description: 'DFS, BFS, shortest paths, MST',\n                        screen: 'graph-algorithms',\n                        icon: 'üõ§Ô∏è'\n                    },\n                    {\n                        id: 'dynamic-programming',\n                        label: 'Dynamic Programming',\n                        description: 'Memoization, tabulation, optimization',\n                        screen: 'dynamic-programming',\n                        icon: '‚ö°'\n                    },\n                    {\n                        id: 'greedy',\n                        label: 'Greedy Algorithms',\n                        description: 'Local optimization strategies',\n                        screen: 'greedy',\n                        icon: 'üéØ'\n                    }\n                ]\n            }],\n            ['practice', {\n                id: 'practice',\n                title: 'Practice Problems',\n                description: 'Test your skills with coding challenges',\n                parent: 'main',\n                items: [\n                    {\n                        id: 'beginner',\n                        label: 'Beginner Level',\n                        description: '25 problems focusing on basic concepts',\n                        screen: 'practice-beginner',\n                        icon: 'üü¢'\n                    },\n                    {\n                        id: 'intermediate',\n                        label: 'Intermediate Level',\n                        description: '50 problems with moderate complexity',\n                        screen: 'practice-intermediate',\n                        icon: 'üü°'\n                    },\n                    {\n                        id: 'advanced',\n                        label: 'Advanced Level',\n                        description: '30 challenging algorithmic problems',\n                        screen: 'practice-advanced',\n                        icon: 'üî¥'\n                    },\n                    {\n                        id: 'contests',\n                        label: 'Contest Problems',\n                        description: 'Time-limited competitive programming',\n                        screen: 'practice-contests',\n                        icon: 'üèÜ'\n                    }\n                ]\n            }],\n            ['complexity', {\n                id: 'complexity',\n                title: 'Time & Space Complexity',\n                description: 'Understanding algorithmic efficiency',\n                parent: 'fundamentals',\n                content: `\nTime and Space Complexity Analysis\n\n${chalk.cyan('Big O Notation:')}  \nDescribes the upper bound of algorithm performance\n\n${chalk.green('Common Time Complexities:')}\n‚Ä¢ O(1) - Constant time\n‚Ä¢ O(log n) - Logarithmic time  \n‚Ä¢ O(n) - Linear time\n‚Ä¢ O(n log n) - Linearithmic time\n‚Ä¢ O(n¬≤) - Quadratic time\n‚Ä¢ O(2‚Åø) - Exponential time\n\n${chalk.yellow('Space Complexity:')}\nAmount of extra memory used relative to input size\n\n${chalk.blue('Analysis Tips:')}\n‚Ä¢ Focus on worst-case scenarios\n‚Ä¢ Ignore constants and lower-order terms\n‚Ä¢ Consider both time and space trade-offs\n                `,\n                actions: [\n                    { id: 'examples', label: 'View Examples', key: 'e', description: 'See complexity analysis examples' },\n                    { id: 'practice', label: 'Practice Problems', key: 'p', description: 'Solve complexity analysis problems' },\n                    { id: 'quiz', label: 'Take Quiz', key: 'q', description: 'Test your understanding' }\n                ]\n            }],\n            ['settings', {\n                id: 'settings',\n                title: 'Settings',\n                description: 'Customize your learning experience',\n                parent: 'main',\n                items: [\n                    {\n                        id: 'appearance',\n                        label: 'Appearance',\n                        description: 'Theme, colors, and display options',\n                        icon: 'üé®',\n                        action: 'appearance-settings'\n                    },\n                    {\n                        id: 'difficulty',\n                        label: 'Difficulty Level',\n                        description: 'Adjust problem difficulty and hints',\n                        icon: 'üéöÔ∏è',\n                        action: 'difficulty-settings'\n                    },\n                    {\n                        id: 'notifications',\n                        label: 'Notifications',\n                        description: 'Progress updates and reminders',\n                        icon: 'üîî',\n                        action: 'notification-settings'\n                    },\n                    {\n                        id: 'data',\n                        label: 'Data & Privacy',\n                        description: 'Export data, reset progress, privacy',\n                        icon: 'üõ°Ô∏è',\n                        action: 'data-settings'\n                    }\n                ]\n            }]\n        ]);\n    }\n\n    public async start(): Promise<void> {\n        console.clear();\n        this.displayWelcome();\n        \n        while (this.isRunning) {\n            try {\n                await this.displayCurrentScreen();\n                const action = await this.getUserInput();\n                await this.handleAction(action);\n            } catch (error) {\n                console.log(chalk.red('\\n‚ùå Error:'), error.message);\n                await this.waitForUser();\n            }\n        }\n        \n        this.displaySessionSummary();\n    }\n\n    private displayWelcome(): void {\n        console.log(chalk.blue.bold('\\nüß≠ Navigation System Demo'));\n        console.log(chalk.gray('‚ïê'.repeat(50)));\n        console.log(chalk.white('\\nExplore the learning navigation system!'));\n        console.log(chalk.gray('Use arrow keys, numbers, or commands to navigate.\\n'));\n    }\n\n    private async displayCurrentScreen(): Promise<void> {\n        const screen = this.screens.get(this.state.currentScreen);\n        if (!screen) return;\n\n        // Track screen view\n        const views = this.analytics.screenViews.get(screen.id) || 0;\n        this.analytics.screenViews.set(screen.id, views + 1);\n\n        console.clear();\n        \n        // Display breadcrumbs\n        this.displayBreadcrumbs();\n        \n        // Display screen header\n        console.log(chalk.cyan.bold(`\\nüìç ${screen.title}`));\n        if (screen.description) {\n            console.log(chalk.gray(screen.description));\n        }\n        console.log();\n        \n        // Display content or items\n        if (screen.content) {\n            console.log(screen.content);\n            if (screen.actions) {\n                console.log(chalk.yellow('\\nAvailable Actions:'));\n                screen.actions.forEach(action => {\n                    console.log(`  ${chalk.cyan(action.key.toUpperCase())} - ${action.label}: ${chalk.gray(action.description)}`);\n                });\n            }\n        } else if (screen.items) {\n            this.displayMenuItems(screen.items);\n        }\n        \n        // Display navigation help\n        console.log();\n        this.displayNavigationHelp();\n    }\n\n    private displayBreadcrumbs(): void {\n        const breadcrumbText = this.state.breadcrumbs.map((crumb, index) => {\n            if (index === this.state.breadcrumbs.length - 1) {\n                return chalk.white.bold(crumb);\n            } else {\n                return chalk.blue.underline(crumb);\n            }\n        }).join(chalk.gray(' ‚Ä∫ '));\n        \n        console.log(`\\nüè† ${breadcrumbText}`);\n    }\n\n    private displayMenuItems(items: MenuItem[]): void {\n        console.log(chalk.yellow('Available Options:'));\n        \n        items.forEach((item, index) => {\n            const isSelected = index === this.state.selectedIndex;\n            const prefix = isSelected ? chalk.cyan('‚ñ∫') : ' ';\n            const number = chalk.gray(`[${item.shortcut || (index + 1)}]`);\n            const icon = item.icon || '‚Ä¢';\n            const label = isSelected ? chalk.white.bold(item.label) : chalk.white(item.label);\n            const description = item.description ? chalk.gray(` - ${item.description}`) : '';\n            const enabled = item.enabled !== false ? '' : chalk.red(' (Disabled)');\n            \n            console.log(`${prefix} ${number} ${icon} ${label}${description}${enabled}`);\n        });\n    }\n\n    private displayNavigationHelp(): void {\n        const helpItems = [\n            '‚Üë‚Üì Navigate',\n            'Enter Select',\n            'Esc/Back Go Back',\n            'H Help',\n            'S Search',\n            'Q Quit'\n        ];\n        \n        const helpText = helpItems.map(item => chalk.gray(item)).join(chalk.dim(' | '));\n        console.log(chalk.dim(`\\nüí° Navigation: ${helpText}`));\n    }\n\n    private async getUserInput(): Promise<string> {\n        const { action } = await inquirer.prompt([{\n            type: 'input',\n            name: 'action',\n            message: chalk.cyan('Enter command:'),\n            validate: (input: string) => {\n                if (!input.trim()) return 'Please enter a command';\n                return true;\n            }\n        }]);\n        \n        return action.toLowerCase().trim();\n    }\n\n    private async handleAction(action: string): Promise<void> {\n        this.state.lastAction = action;\n        this.analytics.navigationActions.push(`${Date.now()}: ${action}`);\n        \n        const screen = this.screens.get(this.state.currentScreen);\n        if (!screen) return;\n\n        // Handle navigation commands\n        switch (action) {\n            case 'up':\n            case 'u':\n                this.navigateUp();\n                break;\n                \n            case 'down':\n            case 'd':\n                this.navigateDown();\n                break;\n                \n            case 'enter':\n            case '':\n                await this.selectCurrentItem();\n                break;\n                \n            case 'back':\n            case 'esc':\n            case 'b':\n                this.goBack();\n                break;\n                \n            case 'home':\n            case 'h':\n                await this.showHelp();\n                break;\n                \n            case 'search':\n            case 's':\n                await this.performSearch();\n                break;\n                \n            case 'analytics':\n            case 'a':\n                this.showAnalytics();\n                break;\n                \n            case 'quit':\n            case 'q':\n            case 'exit':\n                this.isRunning = false;\n                break;\n                \n            default:\n                // Try numeric selection\n                const numMatch = action.match(/^(\\d+)$/);\n                if (numMatch) {\n                    const index = parseInt(numMatch[1]) - 1;\n                    await this.selectItemByIndex(index);\n                } else {\n                    // Try shortcut selection\n                    await this.selectItemByShortcut(action);\n                }\n                break;\n        }\n    }\n\n    private navigateUp(): void {\n        const screen = this.screens.get(this.state.currentScreen);\n        if (screen?.items) {\n            this.state.selectedIndex = Math.max(0, this.state.selectedIndex - 1);\n        }\n    }\n\n    private navigateDown(): void {\n        const screen = this.screens.get(this.state.currentScreen);\n        if (screen?.items) {\n            this.state.selectedIndex = Math.min(screen.items.length - 1, this.state.selectedIndex + 1);\n        }\n    }\n\n    private async selectCurrentItem(): Promise<void> {\n        const screen = this.screens.get(this.state.currentScreen);\n        if (screen?.items) {\n            await this.selectItemByIndex(this.state.selectedIndex);\n        }\n    }\n\n    private async selectItemByIndex(index: number): Promise<void> {\n        const screen = this.screens.get(this.state.currentScreen);\n        if (!screen?.items || index < 0 || index >= screen.items.length) {\n            console.log(chalk.red('\\n‚ùå Invalid selection'));\n            await this.waitForUser();\n            return;\n        }\n        \n        const item = screen.items[index];\n        if (item.enabled === false) {\n            console.log(chalk.yellow('\\n‚ö†Ô∏è This option is currently disabled'));\n            await this.waitForUser();\n            return;\n        }\n        \n        if (item.screen) {\n            this.navigateToScreen(item.screen);\n        } else if (item.action) {\n            await this.executeAction(item.action);\n        } else {\n            console.log(chalk.green(`\\n‚úÖ Selected: ${item.label}`));\n            await this.waitForUser();\n        }\n    }\n\n    private async selectItemByShortcut(shortcut: string): Promise<void> {\n        const screen = this.screens.get(this.state.currentScreen);\n        if (!screen?.items) return;\n        \n        const item = screen.items.find(item => \n            item.shortcut?.toLowerCase() === shortcut ||\n            item.id.toLowerCase() === shortcut\n        );\n        \n        if (item) {\n            const index = screen.items.indexOf(item);\n            this.state.selectedIndex = index;\n            await this.selectCurrentItem();\n        } else {\n            console.log(chalk.red(`\\n‚ùå No option found for '${shortcut}'`));\n            await this.waitForUser();\n        }\n    }\n\n    private navigateToScreen(screenId: string): void {\n        const targetScreen = this.screens.get(screenId);\n        if (!targetScreen) {\n            console.log(chalk.red(`\\n‚ùå Screen '${screenId}' not found`));\n            return;\n        }\n        \n        // Add current screen to history\n        this.state.history.push(this.state.currentScreen);\n        \n        // Navigate to new screen\n        this.state.currentScreen = screenId;\n        this.state.selectedIndex = 0;\n        \n        // Update breadcrumbs\n        this.updateBreadcrumbs();\n    }\n\n    private goBack(): void {\n        if (this.state.history.length > 0) {\n            this.state.currentScreen = this.state.history.pop()!;\n            this.state.selectedIndex = 0;\n            this.updateBreadcrumbs();\n        } else {\n            console.log(chalk.yellow('\\n‚ö†Ô∏è Already at the main screen'));\n        }\n    }\n\n    private updateBreadcrumbs(): void {\n        const breadcrumbs = ['Home'];\n        \n        // Build breadcrumb path\n        let currentScreenId = this.state.currentScreen;\n        const path = [];\n        \n        while (currentScreenId && currentScreenId !== 'main') {\n            const screen = this.screens.get(currentScreenId);\n            if (screen) {\n                path.unshift(screen.title);\n                currentScreenId = screen.parent;\n            } else {\n                break;\n            }\n        }\n        \n        this.state.breadcrumbs = breadcrumbs.concat(path);\n    }\n\n    private async showHelp(): Promise<void> {\n        console.clear();\n        console.log(chalk.blue.bold('\\nüìñ Navigation Help'));\n        console.log(chalk.gray('‚ïê'.repeat(30)));\n        \n        const helpSections = [\n            {\n                title: 'Basic Navigation',\n                items: [\n                    '‚Üë/‚Üì or u/d - Navigate up/down in menus',\n                    'Enter or just press Enter - Select current item',\n                    'Esc or b - Go back to previous screen',\n                    '1-9 - Select item by number',\n                    'Letter - Select by shortcut key'\n                ]\n            },\n            {\n                title: 'Commands',\n                items: [\n                    'h - Show this help',\n                    's - Search for content',\n                    'a - View navigation analytics',\n                    'q - Quit the demo'\n                ]\n            },\n            {\n                title: 'Screen Types',\n                items: [\n                    'Menu screens - Navigate with arrow keys or numbers',\n                    'Content screens - Read content and use action keys',\n                    'Settings screens - Configure options'\n                ]\n            }\n        ];\n        \n        helpSections.forEach(section => {\n            console.log(chalk.yellow(`\\n${section.title}:`));\n            section.items.forEach(item => {\n                console.log(`  ‚Ä¢ ${chalk.white(item)}`);\n            });\n        });\n        \n        console.log(chalk.green('\\n‚ú® Tips:'));\n        console.log(chalk.white('  ‚Ä¢ Use breadcrumbs at the top to see your location'));\n        console.log(chalk.white('  ‚Ä¢ Look for icons and shortcuts for faster navigation'));\n        console.log(chalk.white('  ‚Ä¢ Check the bottom for available commands'));\n        \n        await this.waitForUser();\n    }\n\n    private async performSearch(): Promise<void> {\n        console.clear();\n        console.log(chalk.blue.bold('\\nüîç Search'));\n        \n        const { query } = await inquirer.prompt([{\n            type: 'input',\n            name: 'query',\n            message: 'Enter search terms:'\n        }]);\n        \n        if (!query.trim()) return;\n        \n        console.log(chalk.yellow(`\\nSearching for: \"${query}\"...\\n`));\n        \n        // Search through all screens and items\n        const results = [];\n        for (const [screenId, screen] of this.screens) {\n            if (screen.title.toLowerCase().includes(query.toLowerCase()) ||\n                screen.description?.toLowerCase().includes(query.toLowerCase())) {\n                results.push({ type: 'screen', screen, path: this.getScreenPath(screenId) });\n            }\n            \n            if (screen.items) {\n                for (const item of screen.items) {\n                    if (item.label.toLowerCase().includes(query.toLowerCase()) ||\n                        item.description?.toLowerCase().includes(query.toLowerCase())) {\n                        results.push({ type: 'item', item, screen, path: this.getScreenPath(screenId) });\n                    }\n                }\n            }\n        }\n        \n        if (results.length === 0) {\n            console.log(chalk.red('No results found.'));\n        } else {\n            console.log(chalk.green(`Found ${results.length} result(s):\\n`));\n            \n            results.forEach((result, index) => {\n                const path = result.path.join(' ‚Ä∫ ');\n                if (result.type === 'screen') {\n                    console.log(`${chalk.cyan(`${index + 1}.`)} ${chalk.white.bold(result.screen.title)}`);\n                    console.log(`   ${chalk.gray(path)}`);\n                    if (result.screen.description) {\n                        console.log(`   ${chalk.gray(result.screen.description)}`);\n                    }\n                } else {\n                    console.log(`${chalk.cyan(`${index + 1}.`)} ${chalk.white.bold(result.item.label)}`);\n                    console.log(`   ${chalk.gray(path)}`);\n                    if (result.item.description) {\n                        console.log(`   ${chalk.gray(result.item.description)}`);\n                    }\n                }\n                console.log();\n            });\n        }\n        \n        await this.waitForUser();\n    }\n\n    private getScreenPath(screenId: string): string[] {\n        const path = [];\n        let currentScreenId = screenId;\n        \n        while (currentScreenId) {\n            const screen = this.screens.get(currentScreenId);\n            if (screen) {\n                path.unshift(screen.title);\n                currentScreenId = screen.parent;\n            } else {\n                break;\n            }\n        }\n        \n        return path;\n    }\n\n    private showAnalytics(): void {\n        console.clear();\n        console.log(chalk.blue.bold('\\nüìä Navigation Analytics'));\n        console.log(chalk.gray('‚ïê'.repeat(40)));\n        \n        const sessionDuration = Date.now() - this.analytics.sessionStart;\n        const minutes = Math.floor(sessionDuration / 60000);\n        const seconds = Math.floor((sessionDuration % 60000) / 1000);\n        \n        console.log(chalk.yellow('\\nSession Information:'));\n        console.log(`  Duration: ${chalk.white(`${minutes}m ${seconds}s`)}`);\n        console.log(`  Current Screen: ${chalk.white(this.state.currentScreen)}`);\n        console.log(`  Screens in History: ${chalk.white(this.state.history.length)}`);\n        console.log(`  Total Actions: ${chalk.white(this.analytics.navigationActions.length)}`);\n        \n        console.log(chalk.yellow('\\nScreen Views:'));\n        for (const [screenId, views] of this.analytics.screenViews.entries()) {\n            const screen = this.screens.get(screenId);\n            console.log(`  ${screen?.title || screenId}: ${chalk.white(`${views} view${views !== 1 ? 's' : ''}`)}`);\n        }\n        \n        console.log(chalk.yellow('\\nRecent Actions:'));\n        const recentActions = this.analytics.navigationActions.slice(-10);\n        recentActions.forEach((action, index) => {\n            const [timestamp, command] = action.split(': ');\n            const time = new Date(parseInt(timestamp)).toLocaleTimeString();\n            console.log(`  ${chalk.gray(time)} ${chalk.white(command)}`);\n        });\n    }\n\n    private async executeAction(actionId: string): Promise<void> {\n        console.log(chalk.green(`\\n‚ö° Executing action: ${actionId}`));\n        console.log(chalk.gray('(This would trigger the specific action in a real application)'));\n        await this.waitForUser();\n    }\n\n    private async waitForUser(message: string = 'Press Enter to continue...'): Promise<void> {\n        await inquirer.prompt([{\n            type: 'input',\n            name: 'continue',\n            message: chalk.gray(message)\n        }]);\n    }\n\n    private displaySessionSummary(): void {\n        console.clear();\n        console.log(chalk.green.bold('\\nüéØ Navigation Demo Complete'));\n        console.log(chalk.gray('‚ïê'.repeat(40)));\n        \n        const sessionDuration = Date.now() - this.analytics.sessionStart;\n        const minutes = Math.floor(sessionDuration / 60000);\n        const seconds = Math.floor((sessionDuration % 60000) / 1000);\n        \n        console.log(chalk.white('\\nSession Summary:'));\n        console.log(`  ‚Ä¢ Duration: ${chalk.cyan(`${minutes}m ${seconds}s`)}`);\n        console.log(`  ‚Ä¢ Screens Visited: ${chalk.cyan(this.analytics.screenViews.size)}`);\n        console.log(`  ‚Ä¢ Total Actions: ${chalk.cyan(this.analytics.navigationActions.length)}`);\n        console.log(`  ‚Ä¢ Final Location: ${chalk.cyan(this.state.currentScreen)}`);\n        \n        console.log(chalk.white('\\nDemo Features Explored:'));\n        console.log('  ‚úÖ Menu navigation');\n        console.log('  ‚úÖ Breadcrumb tracking');\n        console.log('  ‚úÖ Screen hierarchy');\n        console.log('  ‚úÖ Search functionality');\n        console.log('  ‚úÖ Navigation analytics');\n        console.log('  ‚úÖ Help system');\n        \n        console.log(chalk.gray('\\nThank you for trying the navigation demo!\\n'));\n    }\n}\n\n// Main execution\nif (require.main === module) {\n    const demo = new NavigationDemo();\n    demo.start().catch(error => {\n        console.error(chalk.red('\\nNavigation demo failed:'), error.message);\n        process.exit(1);\n    });\n}\n\nexport default NavigationDemo;"