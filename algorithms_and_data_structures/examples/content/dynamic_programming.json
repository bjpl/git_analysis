{
  "lessonPack": {
    "id": "dynamic-programming",
    "title": "Dynamic Programming",
    "description": "Master the art of solving complex problems by breaking them into simpler subproblems",
    "version": "1.0.0",
    "difficulty": "intermediate-to-advanced",
    "estimatedHours": 25,
    "category": "algorithms",
    "tags": ["dynamic-programming", "optimization", "recursion", "memoization"],
    "prerequisites": ["recursion", "algorithms-fundamentals", "mathematical-reasoning"],
    "learningObjectives": [
      "Understand the principles of dynamic programming",
      "Identify problems suitable for DP solutions",
      "Master memoization and tabulation techniques",
      "Optimize recursive solutions using DP",
      "Solve classic DP problems efficiently",
      "Analyze space and time complexity of DP solutions"
    ],
    "lessons": [
      {
        "id": "dp-introduction",
        "title": "Introduction to Dynamic Programming",
        "description": "Understanding the fundamental concepts and when to apply DP",
        "order": 1,
        "difficulty": "intermediate",
        "estimatedMinutes": 90,
        "learningObjectives": [
          "Understand what dynamic programming is",
          "Identify overlapping subproblems and optimal substructure",
          "Distinguish between top-down and bottom-up approaches",
          "Apply memoization to recursive solutions"
        ],
        "content": {
          "theory": {
            "definition": "Dynamic Programming is an algorithmic technique for solving optimization problems by breaking them down into simpler subproblems",
            "keyPrinciples": {
              "overlappingSubproblems": "The problem can be broken down into subproblems which are reused several times",
              "optimalSubstructure": "An optimal solution can be constructed from optimal solutions of its subproblems"
            },
            "approaches": {
              "topDown": {
                "name": "Memoization",
                "description": "Solve problem recursively and store results of subproblems",
                "advantages": ["Natural recursive structure", "Only solves needed subproblems"],
                "disadvantages": ["Function call overhead", "Stack overflow risk"]
              },
              "bottomUp": {
                "name": "Tabulation",
                "description": "Solve subproblems first and use their solutions to build up to the main problem",
                "advantages": ["No recursion overhead", "Better space optimization"],\n                \"disadvantages\": [\"May solve unnecessary subproblems\", \"Less intuitive structure\"]\n              }\n            },\n            \"whenToUseDP\": [\n              \"Problem can be broken into overlapping subproblems\",\n              \"Problem has optimal substructure\",\n              \"Recursive solution exists but is inefficient\",\n              \"Problem involves optimization (min/max)\"\n            ]\n          },\n          \"implementation\": {\n            \"language\": \"python\",\n            \"code\": \"def fibonacci_recursive(n):\n    \\\"\\\"\\\"\\n    Naive recursive Fibonacci - exponential time O(2^n)\\n    This demonstrates the need for dynamic programming\\n    \\\"\\\"\\\"\\n    if n <= 1:\\n        return n\\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\\n\\ndef fibonacci_memoized(n, memo=None):\\n    \\\"\\\"\\\"\\n    Top-down DP approach using memoization\\n    Time: O(n), Space: O(n)\\n    \\\"\\\"\\\"\\n    if memo is None:\\n        memo = {}\\n    \\n    if n in memo:\\n        return memo[n]\\n    \\n    if n <= 1:\\n        return n\\n    \\n    memo[n] = fibonacci_memoized(n-1, memo) + fibonacci_memoized(n-2, memo)\\n    return memo[n]\\n\\ndef fibonacci_tabulation(n):\\n    \\\"\\\"\\\"\\n    Bottom-up DP approach using tabulation\\n    Time: O(n), Space: O(n)\\n    \\\"\\\"\\\"\\n    if n <= 1:\\n        return n\\n    \\n    # Create table to store results\\n    dp = [0] * (n + 1)\\n    dp[0] = 0\\n    dp[1] = 1\\n    \\n    # Fill table bottom-up\\n    for i in range(2, n + 1):\\n        dp[i] = dp[i-1] + dp[i-2]\\n    \\n    return dp[n]\\n\\ndef fibonacci_optimized(n):\\n    \\\"\\\"\\\"\\n    Space-optimized DP - only keep last two values\\n    Time: O(n), Space: O(1)\\n    \\\"\\\"\\\"\\n    if n <= 1:\\n        return n\\n    \\n    prev2 = 0  # dp[i-2]\\n    prev1 = 1  # dp[i-1]\\n    \\n    for i in range(2, n + 1):\\n        current = prev1 + prev2\\n        prev2 = prev1\\n        prev1 = current\\n    \\n    return prev1\\n\\n# Performance comparison\\nimport time\\n\\ndef compare_fibonacci_approaches():\\n    \\\"\\\"\\\"Compare different approaches to solving Fibonacci\\\"\\\"\\\"\\n    n = 35  # Large enough to see difference\\n    \\n    # Recursive approach (commented out as it's too slow)\\n    # start = time.time()\\n    # result_recursive = fibonacci_recursive(n)\\n    # time_recursive = time.time() - start\\n    \\n    # Memoized approach\\n    start = time.time()\\n    result_memoized = fibonacci_memoized(n)\\n    time_memoized = time.time() - start\\n    \\n    # Tabulation approach\\n    start = time.time()\\n    result_tabulation = fibonacci_tabulation(n)\\n    time_tabulation = time.time() - start\\n    \\n    # Optimized approach\\n    start = time.time()\\n    result_optimized = fibonacci_optimized(n)\\n    time_optimized = time.time() - start\\n    \\n    print(f\\\"Fibonacci({n}) = {result_memoized}\\\")\\n    print(f\\\"Memoized time: {time_memoized:.6f} seconds\\\")\\n    print(f\\\"Tabulation time: {time_tabulation:.6f} seconds\\\")\\n    print(f\\\"Optimized time: {time_optimized:.6f} seconds\\\")\\n    \\n    # Verify all approaches give same result\\n    assert result_memoized == result_tabulation == result_optimized\\n    print(\\\"All approaches produce the same result!\\\")\\n\\n# Example of identifying DP opportunity\\ndef max_subarray_naive(arr):\\n    \\\"\\\"\\\"\\n    Naive approach - O(n³) time complexity\\n    This shows why we need DP optimization\\n    \\\"\\\"\\\"\\n    n = len(arr)\\n    max_sum = float('-inf')\\n    \\n    for i in range(n):\\n        for j in range(i, n):\\n            current_sum = sum(arr[i:j+1])\\n            max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n\\ndef max_subarray_dp(arr):\\n    \\\"\\\"\\\"\\n    Kadane's algorithm using DP principles\\n    Time: O(n), Space: O(1)\\n    \\\"\\\"\\\"\\n    if not arr:\\n        return 0\\n    \\n    max_ending_here = max_so_far = arr[0]\\n    \\n    for i in range(1, len(arr)):\\n        # At each position, decide whether to extend previous subarray\\n        # or start new subarray from current element\\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\\n        max_so_far = max(max_so_far, max_ending_here)\\n    \\n    return max_so_far\\n\\n# Pattern recognition helper\\ndef analyze_problem_for_dp(problem_description):\\n    \\\"\\\"\\\"\\n    Helper function to identify DP characteristics\\n    \\\"\\\"\\\"\\n    dp_indicators = {\\n        'overlapping_subproblems': [\\n            'recursive calls with same parameters',\\n            'repeated calculations',\\n            'exponential time complexity in naive solution'\\n        ],\\n        'optimal_substructure': [\\n            'optimal solution contains optimal solutions to subproblems',\\n            'problem asks for minimum/maximum',\\n            'problem asks for number of ways',\\n            'problem can be broken into smaller similar problems'\\n        ],\\n        'decision_making': [\\n            'at each step, make optimal choice',\\n            'choice affects future possibilities',\\n            'need to consider all possibilities'\\n        ]\\n    }\\n    \\n    return dp_indicators\\n\\nif __name__ == \\\"__main__\\\":\\n    print(\\\"Dynamic Programming Introduction\\\")\\n    print(\\\"=\" * 40)\\n    \\n    # Demonstrate Fibonacci approaches\\n    print(\\\"\\\\nFibonacci Comparison:\\\")\\n    compare_fibonacci_approaches()\\n    \\n    # Demonstrate max subarray\\n    test_array = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\\n    print(f\\\"\\\\nMax subarray sum for {test_array}:\\\")\\n    print(f\\\"Naive approach: {max_subarray_naive(test_array)}\\\")\\n    print(f\\\"DP approach: {max_subarray_dp(test_array)}\\\")\\n    \\n    # Show DP analysis framework\\n    print(\\\"\\\\nDP Problem Analysis Framework:\\\")\\n    indicators = analyze_problem_for_dp(\\\"sample problem\\\")\\n    for category, signs in indicators.items():\\n        print(f\\\"\\\\n{category.replace('_', ' ').title()}:\\\")\\n        for sign in signs:\\n            print(f\\\"  - {sign}\\\")\"\n          }\n        },\n        \"exercises\": [\n          {\n            \"id\": \"dp-intro-ex-001\",\n            \"title\": \"Problem Recognition\",\n            \"description\": \"Identify which problems are suitable for dynamic programming\",\n            \"type\": \"analysis\",\n            \"problems\": [\n              {\n                \"problem\": \"Find the shortest path in a weighted graph\",\n                \"isDPSuitable\": false,\n                \"reason\": \"This is better solved with Dijkstra's algorithm; no overlapping subproblems\"\n              },\n              {\n                \"problem\": \"Count number of ways to climb n stairs (1 or 2 steps at a time)\",\n                \"isDPSuitable\": true,\n                \"reason\": \"Has overlapping subproblems and optimal substructure\"\n              },\n              {\n                \"problem\": \"Sort an array of integers\",\n                \"isDPSuitable\": false,\n                \"reason\": \"Sorting doesn't have optimal substructure property for DP\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"id\": \"classic-dp-problems\",\n        \"title\": \"Classic Dynamic Programming Problems\",\n        \"description\": \"Master the most important DP problems that form the foundation\",\n        \"order\": 2,\n        \"difficulty\": \"intermediate\",\n        \"estimatedMinutes\": 120,\n        \"learningObjectives\": [\n          \"Solve coin change problem using DP\",\n          \"Implement longest common subsequence\",\n          \"Master the knapsack problem variations\",\n          \"Understand edit distance calculation\"\n        ],\n        \"content\": {\n          \"theory\": {\n            \"classicProblems\": \"These problems demonstrate core DP patterns that appear in many variations\",\n            \"patterns\": [\n              \"Decision making at each step\",\n              \"Optimization problems (min/max)\",\n              \"Counting problems (number of ways)\",\n              \"Yes/No problems (is it possible)\"\n            ]\n          },\n          \"implementation\": {\n            \"language\": \"python\",\n            \"code\": \"# 1. COIN CHANGE PROBLEM\\ndef coin_change_min_coins(coins, amount):\\n    \\\"\\\"\\\"\\n    Find minimum number of coins to make given amount\\n    Classic DP problem demonstrating optimal substructure\\n    Time: O(amount * len(coins)), Space: O(amount)\\n    \\\"\\\"\\\"\\n    # dp[i] represents minimum coins needed for amount i\\n    dp = [float('inf')] * (amount + 1)\\n    dp[0] = 0  # Base case: 0 coins needed for amount 0\\n    \\n    for i in range(1, amount + 1):\\n        # Try each coin\\n        for coin in coins:\\n            if coin <= i:\\n                # If we can use this coin, update minimum\\n                dp[i] = min(dp[i], dp[i - coin] + 1)\\n    \\n    return dp[amount] if dp[amount] != float('inf') else -1\\n\\ndef coin_change_count_ways(coins, amount):\\n    \\\"\\\"\\\"\\n    Count number of ways to make given amount\\n    Different DP formulation of coin change\\n    Time: O(amount * len(coins)), Space: O(amount)\\n    \\\"\\\"\\\"\\n    # dp[i] represents number of ways to make amount i\\n    dp = [0] * (amount + 1)\\n    dp[0] = 1  # Base case: one way to make amount 0 (use no coins)\\n    \\n    # For each coin\\n    for coin in coins:\\n        # Update all amounts that can use this coin\\n        for i in range(coin, amount + 1):\\n            dp[i] += dp[i - coin]\\n    \\n    return dp[amount]\\n\\n# 2. LONGEST COMMON SUBSEQUENCE (LCS)\\ndef longest_common_subsequence(text1, text2):\\n    \\\"\\\"\\\"\\n    Find length of longest common subsequence\\n    Classic 2D DP problem\\n    Time: O(m * n), Space: O(m * n)\\n    \\\"\\\"\\\"\\n    m, n = len(text1), len(text2)\\n    \\n    # Create DP table\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n    \\n    # Fill table bottom-up\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            if text1[i-1] == text2[j-1]:\\n                # Characters match - extend LCS\\n                dp[i][j] = dp[i-1][j-1] + 1\\n            else:\\n                # Characters don't match - take maximum\\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n    \\n    return dp[m][n]\\n\\ndef lcs_with_sequence(text1, text2):\\n    \\\"\\\"\\\"\\n    Return both length and actual LCS string\\n    \\\"\\\"\\\"\\n    m, n = len(text1), len(text2)\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n    \\n    # Fill DP table\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            if text1[i-1] == text2[j-1]:\\n                dp[i][j] = dp[i-1][j-1] + 1\\n            else:\\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n    \\n    # Reconstruct LCS by backtracking\\n    lcs = []\\n    i, j = m, n\\n    \\n    while i > 0 and j > 0:\\n        if text1[i-1] == text2[j-1]:\\n            lcs.append(text1[i-1])\\n            i -= 1\\n            j -= 1\\n        elif dp[i-1][j] > dp[i][j-1]:\\n            i -= 1\\n        else:\\n            j -= 1\\n    \\n    return dp[m][n], ''.join(reversed(lcs))\\n\\n# 3. 0/1 KNAPSACK PROBLEM\\ndef knapsack_01(weights, values, capacity):\\n    \\\"\\\"\\\"\\n    0/1 Knapsack: each item can be taken at most once\\n    Classic DP optimization problem\\n    Time: O(n * capacity), Space: O(n * capacity)\\n    \\\"\\\"\\\"\\n    n = len(weights)\\n    \\n    # dp[i][w] = maximum value using items 0..i-1 with capacity w\\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\\n    \\n    for i in range(1, n + 1):\\n        for w in range(capacity + 1):\\n            # Option 1: don't take current item\\n            dp[i][w] = dp[i-1][w]\\n            \\n            # Option 2: take current item (if possible)\\n            if weights[i-1] <= w:\\n                dp[i][w] = max(dp[i][w], \\n                              dp[i-1][w - weights[i-1]] + values[i-1])\\n    \\n    return dp[n][capacity]\\n\\ndef knapsack_01_optimized(weights, values, capacity):\\n    \\\"\\\"\\\"\\n    Space-optimized version using only 1D array\\n    Time: O(n * capacity), Space: O(capacity)\\n    \\\"\\\"\\\"\\n    n = len(weights)\\n    dp = [0] * (capacity + 1)\\n    \\n    for i in range(n):\\n        # Traverse backwards to avoid using updated values\\n        for w in range(capacity, weights[i] - 1, -1):\\n            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])\\n    \\n    return dp[capacity]\\n\\n# 4. EDIT DISTANCE (Levenshtein Distance)\\ndef edit_distance(word1, word2):\\n    \\\"\\\"\\\"\\n    Find minimum operations to convert word1 to word2\\n    Operations: insert, delete, replace\\n    Time: O(m * n), Space: O(m * n)\\n    \\\"\\\"\\\"\\n    m, n = len(word1), len(word2)\\n    \\n    # dp[i][j] = min operations to convert word1[0:i] to word2[0:j]\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n    \\n    # Initialize base cases\\n    for i in range(m + 1):\\n        dp[i][0] = i  # Delete all characters\\n    for j in range(n + 1):\\n        dp[0][j] = j  # Insert all characters\\n    \\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            if word1[i-1] == word2[j-1]:\\n                # Characters match - no operation needed\\n                dp[i][j] = dp[i-1][j-1]\\n            else:\\n                # Take minimum of three operations\\n                dp[i][j] = 1 + min(\\n                    dp[i-1][j],      # Delete\\n                    dp[i][j-1],      # Insert\\n                    dp[i-1][j-1]     # Replace\\n                )\\n    \\n    return dp[m][n]\\n\\n# 5. LONGEST INCREASING SUBSEQUENCE\\ndef longest_increasing_subsequence(nums):\\n    \\\"\\\"\\\"\\n    Find length of longest increasing subsequence\\n    Time: O(n²), Space: O(n)\\n    \\\"\\\"\\\"\\n    if not nums:\\n        return 0\\n    \\n    n = len(nums)\\n    # dp[i] = length of LIS ending at position i\\n    dp = [1] * n\\n    \\n    for i in range(1, n):\\n        for j in range(i):\\n            if nums[i] > nums[j]:\\n                dp[i] = max(dp[i], dp[j] + 1)\\n    \\n    return max(dp)\\n\\ndef lis_optimized(nums):\\n    \\\"\\\"\\\"\\n    Optimized LIS using binary search\\n    Time: O(n log n), Space: O(n)\\n    \\\"\\\"\\\"\\n    from bisect import bisect_left\\n    \\n    if not nums:\\n        return 0\\n    \\n    # tails[i] = smallest ending element of increasing subsequence of length i+1\\n    tails = []\\n    \\n    for num in nums:\\n        pos = bisect_left(tails, num)\\n        if pos == len(tails):\\n            tails.append(num)\\n        else:\\n            tails[pos] = num\\n    \\n    return len(tails)\\n\\n# Testing and demonstration\\ndef test_classic_problems():\\n    print(\\\"Classic DP Problems Demonstration\\\")\\n    print(\\\"=\\\" * 40)\\n    \\n    # Test Coin Change\\n    coins = [1, 3, 4]\\n    amount = 6\\n    print(f\\\"Coin Change:\\\")\\n    print(f\\\"Coins: {coins}, Amount: {amount}\\\")\\n    print(f\\\"Min coins needed: {coin_change_min_coins(coins, amount)}\\\")\\n    print(f\\\"Number of ways: {coin_change_count_ways(coins, amount)}\\\")\\n    \\n    # Test LCS\\n    text1, text2 = \\\"abcde\\\", \\\"ace\\\"\\n    length, sequence = lcs_with_sequence(text1, text2)\\n    print(f\\\"\\\\nLongest Common Subsequence:\\\")\\n    print(f\\\"Text1: {text1}, Text2: {text2}\\\")\\n    print(f\\\"LCS length: {length}, LCS: '{sequence}'\\\")\\n    \\n    # Test Knapsack\\n    weights = [1, 3, 4, 5]\\n    values = [1, 4, 5, 7]\\n    capacity = 7\\n    print(f\\\"\\\\n0/1 Knapsack:\\\")\\n    print(f\\\"Weights: {weights}, Values: {values}, Capacity: {capacity}\\\")\\n    print(f\\\"Max value: {knapsack_01(weights, values, capacity)}\\\")\\n    \\n    # Test Edit Distance\\n    word1, word2 = \\\"horse\\\", \\\"ros\\\"\\n    print(f\\\"\\\\nEdit Distance:\\\")\\n    print(f\\\"Word1: {word1}, Word2: {word2}\\\")\\n    print(f\\\"Min operations: {edit_distance(word1, word2)}\\\")\\n    \\n    # Test LIS\\n    nums = [10, 22, 9, 33, 21, 50, 41, 60]\\n    print(f\\\"\\\\nLongest Increasing Subsequence:\\\")\\n    print(f\\\"Array: {nums}\\\")\\n    print(f\\\"LIS length: {longest_increasing_subsequence(nums)}\\\")\\n    print(f\\\"LIS length (optimized): {lis_optimized(nums)}\\\")\\n\\nif __name__ == \\\"__main__\\\":\\n    test_classic_problems()\"\n          }\n        },\n        \"exercises\": [\n          {\n            \"id\": \"classic-dp-ex-001\",\n            \"title\": \"Problem Variations\",\n            \"description\": \"Implement variations of classic DP problems\",\n            \"type\": \"coding\",\n            \"problems\": [\n              {\n                \"title\": \"Unbounded Knapsack\",\n                \"description\": \"Modify 0/1 knapsack to allow unlimited use of each item\",\n                \"difficulty\": \"intermediate\",\n                \"hint\": \"Change the inner loop direction and recurrence relation\"\n              },\n              {\n                \"title\": \"Palindrome Subsequence\",\n                \"description\": \"Find length of longest palindromic subsequence using LCS\",\n                \"difficulty\": \"intermediate\",\n                \"hint\": \"Use LCS with string and its reverse\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"id\": \"advanced-dp-patterns\",\n        \"title\": \"Advanced Dynamic Programming Patterns\",\n        \"description\": \"Explore sophisticated DP techniques and optimization strategies\",\n        \"order\": 3,\n        \"difficulty\": \"advanced\",\n        \"estimatedMinutes\": 150,\n        \"learningObjectives\": [\n          \"Master state space reduction techniques\",\n          \"Implement DP on trees and graphs\",\n          \"Understand digit DP and bitmask DP\",\n          \"Apply DP to game theory problems\"\n        ],\n        \"content\": {\n          \"theory\": {\n            \"advancedPatterns\": [\n              \"State space optimization\",\n              \"DP on trees (tree DP)\",\n              \"DP on graphs\",\n              \"Digit DP for number theory problems\",\n              \"Bitmask DP for subset problems\",\n              \"Interval DP for range problems\",\n              \"Probability DP\"\n            ]\n          },\n          \"implementation\": {\n            \"language\": \"python\",\n            \"code\": \"# ADVANCED DP PATTERNS\\n\\n# 1. MATRIX CHAIN MULTIPLICATION (Interval DP)\\ndef matrix_chain_multiplication(dimensions):\\n    \\\"\\\"\\\"\\n    Find minimum scalar multiplications to multiply chain of matrices\\n    Classic interval DP problem\\n    Time: O(n³), Space: O(n²)\\n    \\\"\\\"\\\"\\n    n = len(dimensions) - 1  # Number of matrices\\n    \\n    # dp[i][j] = minimum multiplications for matrices i to j\\n    dp = [[0] * n for _ in range(n)]\\n    \\n    # l is chain length\\n    for length in range(2, n + 1):\\n        for i in range(n - length + 1):\\n            j = i + length - 1\\n            dp[i][j] = float('inf')\\n            \\n            # Try all possible splits\\n            for k in range(i, j):\\n                cost = (dp[i][k] + dp[k+1][j] + \\n                       dimensions[i] * dimensions[k+1] * dimensions[j+1])\\n                dp[i][j] = min(dp[i][j], cost)\\n    \\n    return dp[0][n-1]\\n\\n# 2. TREE DP - DIAMETER OF BINARY TREE\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\ndef tree_diameter(root):\\n    \\\"\\\"\\\"\\n    Find diameter of binary tree using DP\\n    Time: O(n), Space: O(height)\\n    \\\"\\\"\\\"\\n    max_diameter = 0\\n    \\n    def max_depth(node):\\n        nonlocal max_diameter\\n        \\n        if not node:\\n            return 0\\n        \\n        # Get max depth of left and right subtrees\\n        left_depth = max_depth(node.left)\\n        right_depth = max_depth(node.right)\\n        \\n        # Update diameter if path through current node is longer\\n        max_diameter = max(max_diameter, left_depth + right_depth)\\n        \\n        # Return max depth from current node\\n        return max(left_depth, right_depth) + 1\\n    \\n    max_depth(root)\\n    return max_diameter\\n\\n# 3. BITMASK DP - TRAVELING SALESMAN PROBLEM\\ndef traveling_salesman(dist_matrix):\\n    \\\"\\\"\\\"\\n    Solve TSP using bitmask DP\\n    Time: O(n² * 2^n), Space: O(n * 2^n)\\n    \\\"\\\"\\\"\\n    n = len(dist_matrix)\\n    \\n    # dp[mask][i] = minimum cost to visit all cities in mask, ending at city i\\n    dp = [[float('inf')] * n for _ in range(1 << n)]\\n    \\n    # Start from city 0\\n    dp[1][0] = 0\\n    \\n    for mask in range(1 << n):\\n        for u in range(n):\\n            if not (mask & (1 << u)):\\n                continue\\n            \\n            for v in range(n):\\n                if mask & (1 << v):\\n                    continue\\n                \\n                new_mask = mask | (1 << v)\\n                dp[new_mask][v] = min(dp[new_mask][v], \\n                                     dp[mask][u] + dist_matrix[u][v])\\n    \\n    # Return to starting city\\n    full_mask = (1 << n) - 1\\n    result = float('inf')\\n    for i in range(1, n):\\n        result = min(result, dp[full_mask][i] + dist_matrix[i][0])\\n    \\n    return result\\n\\n# 4. DIGIT DP - COUNT NUMBERS WITH SPECIFIC PROPERTIES\\ndef count_numbers_with_digit_sum(n, target_sum):\\n    \\\"\\\"\\\"\\n    Count numbers <= n with digit sum equal to target_sum\\n    Uses digit DP technique\\n    \\\"\\\"\\\"\\n    s = str(n)\\n    memo = {}\\n    \\n    def dp(pos, current_sum, tight, started):\\n        if pos == len(s):\\n            return 1 if current_sum == target_sum and started else 0\\n        \\n        if (pos, current_sum, tight, started) in memo:\\n            return memo[(pos, current_sum, tight, started)]\\n        \\n        limit = int(s[pos]) if tight else 9\\n        result = 0\\n        \\n        for digit in range(0, limit + 1):\\n            new_tight = tight and (digit == limit)\\n            new_started = started or (digit > 0)\\n            new_sum = current_sum + digit if new_started else 0\\n            \\n            if new_sum <= target_sum:\\n                result += dp(pos + 1, new_sum, new_tight, new_started)\\n        \\n        memo[(pos, current_sum, tight, started)] = result\\n        return result\\n    \\n    return dp(0, 0, True, False)\\n\\n# 5. PROBABILITY DP - COIN FLIP GAME\\ndef coin_flip_probability(n, k):\\n    \\\"\\\"\\\"\\n    Probability of getting exactly k heads in n coin flips\\n    where coin has different probabilities for heads on each flip\\n    \\\"\\\"\\\"\\n    # For this example, assume fair coin (0.5 probability)\\n    # dp[i][j] = probability of getting j heads in first i flips\\n    dp = [[0.0] * (k + 1) for _ in range(n + 1)]\\n    \\n    # Base case: 0 heads in 0 flips has probability 1\\n    dp[0][0] = 1.0\\n    \\n    for i in range(1, n + 1):\\n        for j in range(min(i, k) + 1):\\n            # Probability of getting tails (j heads remain same)\\n            dp[i][j] += dp[i-1][j] * 0.5\\n            \\n            # Probability of getting heads (if j > 0)\\n            if j > 0:\\n                dp[i][j] += dp[i-1][j-1] * 0.5\\n    \\n    return dp[n][k]\\n\\n# 6. GAME THEORY DP - MINIMAX\\ndef optimal_game_strategy(arr):\\n    \\\"\\\"\\\"\\n    Two players pick from ends of array optimally\\n    Find maximum advantage first player can achieve\\n    \\\"\\\"\\\"\\n    n = len(arr)\\n    # dp[i][j] = max advantage first player can get from arr[i:j+1]\\n    dp = [[0] * n for _ in range(n)]\\n    \\n    # Base case: single element\\n    for i in range(n):\\n        dp[i][i] = arr[i]\\n    \\n    # Fill for subarrays of length 2 to n\\n    for length in range(2, n + 1):\\n        for i in range(n - length + 1):\\n            j = i + length - 1\\n            \\n            # Player 1 picks arr[i], player 2 plays optimally on remaining\\n            pick_left = arr[i] - dp[i+1][j]\\n            \\n            # Player 1 picks arr[j], player 2 plays optimally on remaining\\n            pick_right = arr[j] - dp[i][j-1]\\n            \\n            dp[i][j] = max(pick_left, pick_right)\\n    \\n    return dp[0][n-1]\\n\\n# 7. STATE COMPRESSION - MAXIMUM SQUARE\\ndef maximal_square(matrix):\\n    \\\"\\\"\\\"\\n    Find largest square of 1s in binary matrix\\n    Uses DP with state compression\\n    \\\"\\\"\\\"\\n    if not matrix or not matrix[0]:\\n        return 0\\n    \\n    rows, cols = len(matrix), len(matrix[0])\\n    dp = [0] * cols\\n    max_side = 0\\n    prev_diagonal = 0\\n    \\n    for i in range(rows):\\n        for j in range(cols):\\n            temp = dp[j]\\n            \\n            if matrix[i][j] == '1':\\n                if i == 0 or j == 0:\\n                    dp[j] = 1\\n                else:\\n                    dp[j] = min(dp[j], dp[j-1], prev_diagonal) + 1\\n                \\n                max_side = max(max_side, dp[j])\\n            else:\\n                dp[j] = 0\\n            \\n            prev_diagonal = temp\\n    \\n    return max_side * max_side\\n\\n# Testing advanced patterns\\ndef test_advanced_patterns():\\n    print(\\\"Advanced DP Patterns Demonstration\\\")\\n    print(\\\"=\\\" * 45)\\n    \\n    # Matrix Chain Multiplication\\n    dimensions = [1, 2, 3, 4, 5]  # Matrices: 1x2, 2x3, 3x4, 4x5\\n    print(f\\\"Matrix Chain Multiplication:\\\")\\n    print(f\\\"Dimensions: {dimensions}\\\")\\n    print(f\\\"Min multiplications: {matrix_chain_multiplication(dimensions)}\\\")\\n    \\n    # TSP example (small instance)\\n    dist = [\\n        [0, 10, 15, 20],\\n        [10, 0, 35, 25],\\n        [15, 35, 0, 30],\\n        [20, 25, 30, 0]\\n    ]\\n    print(f\\\"\\\\nTraveling Salesman (4 cities):\\\")\\n    print(f\\\"Min tour cost: {traveling_salesman(dist)}\\\")\\n    \\n    # Digit DP\\n    n = 100\\n    target = 9\\n    count = count_numbers_with_digit_sum(n, target)\\n    print(f\\\"\\\\nNumbers <= {n} with digit sum {target}: {count}\\\")\\n    \\n    # Probability DP\\n    prob = coin_flip_probability(5, 3)\\n    print(f\\\"\\\\nProbability of 3 heads in 5 flips: {prob:.4f}\\\")\\n    \\n    # Game Theory\\n    game_arr = [3, 7, 2, 3]\\n    advantage = optimal_game_strategy(game_arr)\\n    print(f\\\"\\\\nOptimal game strategy for {game_arr}:\\\")\\n    print(f\\\"First player advantage: {advantage}\\\")\\n\\nif __name__ == \\\"__main__\\\":\\n    test_advanced_patterns()\"\n          }\n        }\n      },\n      {\n        \"id\": \"dp-optimization\",\n        \"title\": \"DP Optimization Techniques\",\n        \"description\": \"Advanced techniques to optimize DP solutions for time and space\",\n        \"order\": 4,\n        \"difficulty\": \"advanced\",\n        \"estimatedMinutes\": 120,\n        \"content\": {\n          \"theory\": {\n            \"optimizationTechniques\": [\n              \"Space optimization using rolling arrays\",\n              \"Divide and conquer optimization\",\n              \"Convex hull optimization\",\n              \"Knuth-Yao speedup\",\n              \"Matrix exponentiation for linear recurrences\"\n            ]\n          }\n        }\n      }\n    ],\n    \"practiceProblems\": [\n      {\n        \"id\": \"dp-practice-001\",\n        \"title\": \"House Robber Series\",\n        \"description\": \"Progressive difficulty in applying DP to robbery scenarios\",\n        \"difficulty\": \"beginner-to-intermediate\",\n        \"problems\": [\n          {\n            \"title\": \"House Robber I\",\n            \"description\": \"Rob houses in a line without robbing adjacent houses\",\n            \"difficulty\": \"beginner\"\n          },\n          {\n            \"title\": \"House Robber II\",\n            \"description\": \"Houses arranged in circle - first and last are adjacent\",\n            \"difficulty\": \"intermediate\"\n          },\n          {\n            \"title\": \"House Robber III\",\n            \"description\": \"Houses arranged in binary tree structure\",\n            \"difficulty\": \"intermediate\"\n          }\n        ]\n      },\n      {\n        \"id\": \"dp-practice-002\",\n        \"title\": \"Stock Trading Problems\",\n        \"description\": \"DP applications in financial optimization\",\n        \"difficulty\": \"intermediate-to-advanced\",\n        \"problems\": [\n          {\n            \"title\": \"Best Time to Buy and Sell Stock\",\n            \"description\": \"Single transaction for maximum profit\",\n            \"difficulty\": \"beginner\"\n          },\n          {\n            \"title\": \"Best Time to Buy and Sell Stock II\",\n            \"description\": \"Multiple transactions allowed\",\n            \"difficulty\": \"intermediate\"\n          },\n          {\n            \"title\": \"Best Time to Buy and Sell Stock with Cooldown\",\n            \"description\": \"Must wait one day after selling before buying again\",\n            \"difficulty\": \"advanced\"\n          }\n        ]\n      }\n    ],\n    \"assessments\": [\n      {\n        \"id\": \"dp-assessment-basic\",\n        \"title\": \"Basic DP Concepts\",\n        \"type\": \"quiz\",\n        \"questions\": [\n          {\n            \"id\": \"q1\",\n            \"question\": \"What are the two key properties required for dynamic programming?\",\n            \"type\": \"multiple-select\",\n            \"options\": [\n              \"Overlapping subproblems\",\n              \"Optimal substructure\",\n              \"Greedy choice property\",\n              \"Divide and conquer structure\"\n            ],\n            \"correct\": [0, 1],\n            \"explanation\": \"DP requires overlapping subproblems (same subproblems solved multiple times) and optimal substructure (optimal solution contains optimal solutions to subproblems)\"\n          },\n          {\n            \"id\": \"q2\",\n            \"question\": \"What is the time complexity of the naive recursive Fibonacci solution?\",\n            \"type\": \"multiple-choice\",\n            \"options\": [\"O(n)\", \"O(n log n)\", \"O(n²)\", \"O(2^n)\"],\n            \"correct\": 3,\n            \"explanation\": \"Each recursive call branches into two more calls, creating exponential time complexity\"\n          }\n        ]\n      },\n      {\n        \"id\": \"dp-assessment-implementation\",\n        \"title\": \"DP Implementation Challenge\",\n        \"type\": \"coding\",\n        \"description\": \"Implement and optimize a DP solution\",\n        \"problem\": {\n          \"title\": \"Unique Paths\",\n          \"description\": \"Robot moves from top-left to bottom-right of grid, only right and down moves allowed. Count unique paths.\",\n          \"constraints\": \"1 <= m, n <= 100\",\n          \"examples\": [\n            {\n              \"input\": \"m = 3, n = 7\",\n              \"output\": \"28\"\n            }\n          ]\n        },\n        \"requirements\": [\n          \"Implement both memoized and tabulated solutions\",\n          \"Optimize space complexity\",\n          \"Handle edge cases\",\n          \"Analyze time and space complexity\"\n        ]\n      }\n    ],\n    \"resources\": [\n      {\n        \"type\": \"interactive\",\n        \"title\": \"DP Visualizer\",\n        \"url\": \"https://algorithm-visualizer.org/dynamic-programming\",\n        \"description\": \"Interactive visualizations of DP algorithms\"\n      },\n      {\n        \"type\": \"practice\",\n        \"title\": \"LeetCode DP Problems\",\n        \"url\": \"https://leetcode.com/tag/dynamic-programming/\",\n        \"description\": \"Comprehensive collection of DP problems\"\n      },\n      {\n        \"type\": \"reference\",\n        \"title\": \"DP Patterns Guide\",\n        \"description\": \"Common DP patterns and when to apply them\"\n      }\n    ]\n  }\n}"