// Main services export file\n\n// API Services\nexport { unsplashService, UnsplashService, UnsplashUtils, type UnsplashPhoto, type UnsplashSearchParams, type UnsplashConfig } from './unsplashService';\nexport { openaiService, OpenAIService, OpenAIUtils, type OpenAIMessage, type OpenAICompletionRequest, type OpenAICompletionResponse, type GenerateDescriptionOptions } from './openaiService';\nexport { supabaseService, supabase, SupabaseService, type SupabaseConfig, type AuthUser, type AuthError } from './supabaseClient';\n\n// Utility Services\nexport { apiErrorHandler, APIErrorHandler, ErrorUtils, type ErrorHandlerConfig, type ErrorContext } from './apiErrorHandler';\nexport { rateLimiter, RateLimiter, type RateLimiterConfig, type TokenBucket } from './rateLimiter';\nexport { cacheService, imageCache, apiCache, vocabularyCache, CacheService, type CacheConfig } from './cacheService';\nexport { envValidator, EnvironmentValidator, EnvUtils, type EnvironmentConfig, type ValidationResult } from './envValidator';\n\n// Legacy Services (for backward compatibility)\nexport { vocabularyService } from './vocabularyService';\nexport { srsService, SRSService } from './srsService';\n\n// Service Manager for coordinated operations\nexport class ServiceManager {\n  private static instance: ServiceManager;\n  \n  private constructor() {\n    this.initializeServices();\n  }\n  \n  static getInstance(): ServiceManager {\n    if (!ServiceManager.instance) {\n      ServiceManager.instance = new ServiceManager();\n    }\n    return ServiceManager.instance;\n  }\n  \n  /**\n   * Initialize all services with proper configuration\n   */\n  private async initializeServices(): Promise<void> {\n    try {\n      // Validate environment first\n      const envValidation = envValidator.validateEnvironment();\n      if (!envValidation.valid) {\n        console.warn('Environment validation failed:', envValidation);\n        \n        // Log specific issues\n        if (envValidation.missing.length > 0) {\n          console.warn('Missing required environment variables:', envValidation.missing);\n        }\n        \n        if (envValidation.invalid.length > 0) {\n          console.warn('Invalid environment variables:', envValidation.invalid);\n        }\n      }\n      \n      // Configure rate limiting based on environment\n      this.configureRateLimiting();\n      \n      // Configure caching\n      this.configureCaching();\n      \n      // Configure error handling\n      this.configureErrorHandling();\n      \n      console.log('Services initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize services:', error);\n    }\n  }\n  \n  /**\n   * Configure rate limiting based on environment and API limits\n   */\n  private configureRateLimiting(): void {\n    const unsplashLimit = EnvUtils.getNumberEnv('UNSPLASH_RATE_LIMIT', 1000);\n    const openaiLimit = EnvUtils.getNumberEnv('OPENAI_RATE_LIMIT', 60);\n    \n    rateLimiter.configure('unsplash', {\n      windowMs: 60 * 60 * 1000, // 1 hour\n      maxRequests: unsplashLimit,\n      minDelay: 1000,\n      burstSize: 10\n    });\n    \n    rateLimiter.configure('openai', {\n      windowMs: 60 * 1000, // 1 minute\n      maxRequests: openaiLimit,\n      minDelay: 1000,\n      burstSize: 5\n    });\n  }\n  \n  /**\n   * Configure caching based on environment\n   */\n  private configureCaching(): void {\n    const isDev = EnvUtils.isDevelopment();\n    \n    // Adjust cache TTL based on environment\n    if (isDev) {\n      // Shorter TTL in development for faster iteration\n      apiCache.destroy();\n      // Reinitialize with dev settings would go here\n    }\n  }\n  \n  /**\n   * Configure error handling\n   */\n  private configureErrorHandling(): void {\n    const enableErrorReporting = EnvUtils.getBooleanEnv('ENABLE_ERROR_REPORTING', false);\n    const sentryDsn = EnvUtils.getOptionalEnv('SENTRY_DSN', '');\n    \n    // Configure error handler with environment-specific settings\n    // This would integrate with actual error reporting services\n  }\n  \n  /**\n   * Test all service connections\n   */\n  async testAllConnections(): Promise<{\n    success: boolean;\n    results: Record<string, { success: boolean; message: string }>;\n  }> {\n    const results: Record<string, { success: boolean; message: string }> = {};\n    \n    try {\n      // Test Unsplash\n      results.unsplash = await unsplashService.testConnection();\n      \n      // Test OpenAI\n      results.openai = await openaiService.testConnection();\n      \n      // Test Supabase\n      results.supabase = await supabaseService.testConnection();\n      \n      const allSuccessful = Object.values(results).every(result => result.success);\n      \n      return {\n        success: allSuccessful,\n        results\n      };\n    } catch (error) {\n      return {\n        success: false,\n        results: {\n          error: {\n            success: false,\n            message: `Connection test failed: ${(error as Error).message}`\n          }\n        }\n      };\n    }\n  }\n  \n  /**\n   * Get overall service health status\n   */\n  getHealthStatus(): {\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    services: Record<string, 'up' | 'down' | 'degraded'>;\n    environment: {\n      valid: boolean;\n      missingKeys: number;\n      warnings: number;\n    };\n    rateLimit: {\n      unsplash: { remaining: number; resetTime?: Date };\n      openai: { remaining: number; resetTime?: Date };\n    };\n    cache: {\n      size: number;\n      memoryUsage: number;\n      hitRate: number;\n    };\n  } {\n    const envStatus = envValidator.getEnvironmentStatus();\n    const unsplashRateLimit = rateLimiter.getRateLimitStatus('unsplash');\n    const openaiRateLimit = rateLimiter.getRateLimitStatus('openai');\n    const cacheStats = cacheService.getStats();\n    \n    const services = {\n      unsplash: envStatus.isValid ? 'up' : 'down',\n      openai: envStatus.isValid ? 'up' : 'down',\n      supabase: envStatus.isValid ? 'up' : 'down'\n    } as Record<string, 'up' | 'down' | 'degraded'>;\n    \n    // Determine overall status\n    const upCount = Object.values(services).filter(status => status === 'up').length;\n    const totalServices = Object.keys(services).length;\n    \n    let overallStatus: 'healthy' | 'degraded' | 'unhealthy';\n    if (upCount === totalServices && envStatus.isValid) {\n      overallStatus = 'healthy';\n    } else if (upCount > totalServices / 2) {\n      overallStatus = 'degraded';\n    } else {\n      overallStatus = 'unhealthy';\n    }\n    \n    return {\n      status: overallStatus,\n      services,\n      environment: {\n        valid: envStatus.isValid,\n        missingKeys: envStatus.missingKeys,\n        warnings: envStatus.warnings\n      },\n      rateLimit: {\n        unsplash: {\n          remaining: unsplashRateLimit?.remaining || 0,\n          resetTime: unsplashRateLimit?.reset\n        },\n        openai: {\n          remaining: openaiRateLimit?.remaining || 0,\n          resetTime: openaiRateLimit?.reset\n        }\n      },\n      cache: {\n        size: cacheStats.size,\n        memoryUsage: cacheStats.memoryUsageMB,\n        hitRate: cacheStats.hitRate\n      }\n    };\n  }\n  \n  /**\n   * Gracefully shutdown all services\n   */\n  async shutdown(): Promise<void> {\n    try {\n      // Save cache to persistence\n      cacheService.destroy();\n      imageCache.destroy();\n      apiCache.destroy();\n      vocabularyCache.destroy();\n      \n      // Clear rate limiting data\n      rateLimiter.reset('unsplash');\n      rateLimiter.reset('openai');\n      rateLimiter.reset('supabase');\n      \n      console.log('Services shut down gracefully');\n    } catch (error) {\n      console.error('Error during service shutdown:', error);\n    }\n  }\n}\n\n// Export singleton service manager\nexport const serviceManager = ServiceManager.getInstance();\n\n// Convenience exports for common operations\nexport const Services = {\n  unsplash: unsplashService,\n  openai: openaiService,\n  supabase: supabaseService,\n  vocabulary: vocabularyService,\n  srs: srsService,\n  cache: cacheService,\n  rateLimit: rateLimiter,\n  errorHandler: apiErrorHandler,\n  envValidator: envValidator,\n  manager: serviceManager\n};\n\n// Re-export types for convenience\nexport type {\n  Image,\n  UnsplashSearchResponse,\n  AIDescription,\n  VocabularyWord,\n  User,\n  AppError,\n  DetailedAppError,\n  CacheEntry,\n  CacheOptions,\n  RateLimitInfo,\n  NetworkStatus\n} from '../types';"