import { VocabularyItem, SRSReviewSession, ReviewType, MasteryLevel } from '../types';

/**
 * Spaced Repetition System (SRS) Service
 * 
 * Implements a sophisticated spaced repetition algorithm based on:
 * - SuperMemo SM-2 algorithm
 * - Anki's modifications
 * - Custom adjustments for vocabulary learning
 */\n\nexport interface SRSCalculationResult {\n  ease: number;\n  interval: number;\n  masteryLevel: MasteryLevel;\n  nextReviewAt: Date;\n  difficultyAdjustment?: number;\n}\n\nexport interface SRSConfig {\n  // Base intervals (in days)\n  initialInterval: number;\n  graduatingInterval: number;\n  easyInterval: number;\n  \n  // Ease factors\n  initialEase: number;\n  minEase: number;\n  maxEase: number;\n  \n  // Adjustments\n  easyBonus: number;\n  hardPenalty: number;\n  againPenalty: number;\n  \n  // Learning steps (in minutes)\n  learningSteps: number[];\n  relearningSteps: number[];\n  \n  // Mastery thresholds\n  masteryThreshold: number;\n  retentionTarget: number;\n}\n\n// Default SRS configuration optimized for vocabulary learning\nconst DEFAULT_CONFIG: SRSConfig = {\n  initialInterval: 1,\n  graduatingInterval: 4,\n  easyInterval: 7,\n  \n  initialEase: 2.5,\n  minEase: 1.3,\n  maxEase: 4.0,\n  \n  easyBonus: 0.15,\n  hardPenalty: 0.15,\n  againPenalty: 0.20,\n  \n  learningSteps: [1, 10, 60], // 1 min, 10 min, 1 hour\n  relearningSteps: [10, 60],   // 10 min, 1 hour\n  \n  masteryThreshold: 21,        // Days interval for mastery\n  retentionTarget: 0.85        // 85% retention target\n};\n\nclass SRSService {\n  private config: SRSConfig;\n  \n  constructor(config: Partial<SRSConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Calculate the next review parameters based on performance\n   */\n  calculateNextReview(\n    item: VocabularyItem,\n    performance: 'again' | 'hard' | 'good' | 'easy',\n    responseTime?: number\n  ): SRSCalculationResult {\n    const now = new Date();\n    let { ease, interval, masteryLevel } = item;\n    \n    // Initialize defaults for new items\n    if (ease === 0 || !ease) ease = this.config.initialEase;\n    if (interval === 0 || !interval) interval = this.config.initialInterval;\n    \n    // Handle different performance levels\n    switch (performance) {\n      case 'again':\n        return this.handleAgainResponse(item, now);\n      case 'hard':\n        return this.handleHardResponse(item, now);\n      case 'good':\n        return this.handleGoodResponse(item, now);\n      case 'easy':\n        return this.handleEasyResponse(item, now);\n      default:\n        throw new Error(`Invalid performance: ${performance}`);\n    }\n  }\n\n  /**\n   * Handle 'Again' response - card was forgotten\n   */\n  private handleAgainResponse(item: VocabularyItem, now: Date): SRSCalculationResult {\n    const newEase = Math.max(\n      this.config.minEase,\n      item.ease - this.config.againPenalty\n    );\n    \n    // Reset to learning if was in review/mastered\n    const masteryLevel = item.masteryLevel === MasteryLevel.NEW \n      ? MasteryLevel.NEW \n      : MasteryLevel.LEARNING;\n    \n    // Use relearning steps or reset to initial\n    const interval = masteryLevel === MasteryLevel.LEARNING \n      ? this.config.relearningSteps[0] / (24 * 60) // Convert minutes to days\n      : this.config.initialInterval;\n    \n    const nextReviewAt = this.addDaysToDate(now, interval);\n    \n    return {\n      ease: newEase,\n      interval,\n      masteryLevel,\n      nextReviewAt,\n      difficultyAdjustment: Math.min(10, item.difficulty + 1)\n    };\n  }\n\n  /**\n   * Handle 'Hard' response - card was difficult but remembered\n   */\n  private handleHardResponse(item: VocabularyItem, now: Date): SRSCalculationResult {\n    const newEase = Math.max(\n      this.config.minEase,\n      item.ease - this.config.hardPenalty\n    );\n    \n    let interval: number;\n    let masteryLevel = item.masteryLevel;\n    \n    if (item.masteryLevel === MasteryLevel.NEW) {\n      // Move to learning but with shorter interval\n      interval = this.config.initialInterval * 0.8;\n      masteryLevel = MasteryLevel.LEARNING;\n    } else {\n      // Reduce interval slightly\n      interval = item.interval * 1.2;\n    }\n    \n    const nextReviewAt = this.addDaysToDate(now, interval);\n    \n    return {\n      ease: newEase,\n      interval,\n      masteryLevel,\n      nextReviewAt\n    };\n  }\n\n  /**\n   * Handle 'Good' response - normal successful recall\n   */\n  private handleGoodResponse(item: VocabularyItem, now: Date): SRSCalculationResult {\n    let interval: number;\n    let masteryLevel = item.masteryLevel;\n    const ease = item.ease; // No ease change for good response\n    \n    if (item.masteryLevel === MasteryLevel.NEW) {\n      interval = this.config.graduatingInterval;\n      masteryLevel = MasteryLevel.LEARNING;\n    } else if (item.masteryLevel === MasteryLevel.LEARNING && item.streak >= 2) {\n      interval = this.config.graduatingInterval;\n      masteryLevel = MasteryLevel.REVIEW;\n    } else {\n      // Apply ease factor\n      interval = item.interval * ease;\n      \n      // Check for mastery\n      if (interval >= this.config.masteryThreshold && item.streak >= 5) {\n        masteryLevel = MasteryLevel.MASTERED;\n      }\n    }\n    \n    const nextReviewAt = this.addDaysToDate(now, interval);\n    \n    return {\n      ease,\n      interval,\n      masteryLevel,\n      nextReviewAt\n    };\n  }\n\n  /**\n   * Handle 'Easy' response - very easy recall\n   */\n  private handleEasyResponse(item: VocabularyItem, now: Date): SRSCalculationResult {\n    const newEase = Math.min(\n      this.config.maxEase,\n      item.ease + this.config.easyBonus\n    );\n    \n    let interval: number;\n    let masteryLevel = item.masteryLevel;\n    \n    if (item.masteryLevel === MasteryLevel.NEW) {\n      interval = this.config.easyInterval;\n      masteryLevel = MasteryLevel.REVIEW;\n    } else {\n      // Apply ease factor with bonus\n      interval = item.interval * newEase * 1.3; // Additional easy bonus\n      \n      // Fast track to mastery\n      if (interval >= this.config.masteryThreshold) {\n        masteryLevel = MasteryLevel.MASTERED;\n      }\n    }\n    \n    const nextReviewAt = this.addDaysToDate(now, interval);\n    \n    return {\n      ease: newEase,\n      interval,\n      masteryLevel,\n      nextReviewAt,\n      difficultyAdjustment: Math.max(1, item.difficulty - 1)\n    };\n  }\n\n  /**\n   * Get items due for review\n   */\n  getDueItems(items: VocabularyItem[]): VocabularyItem[] {\n    const now = new Date();\n    \n    return items.filter(item => {\n      if (!item.nextReviewAt) {\n        return item.masteryLevel === MasteryLevel.NEW;\n      }\n      return new Date(item.nextReviewAt) <= now;\n    }).sort((a, b) => {\n      // Prioritize by due date, then by mastery level\n      const aDate = a.nextReviewAt ? new Date(a.nextReviewAt) : new Date(0);\n      const bDate = b.nextReviewAt ? new Date(b.nextReviewAt) : new Date(0);\n      \n      if (aDate.getTime() !== bDate.getTime()) {\n        return aDate.getTime() - bDate.getTime();\n      }\n      \n      // Prioritize new and learning items\n      const masteryOrder = {\n        [MasteryLevel.NEW]: 0,\n        [MasteryLevel.LEARNING]: 1,\n        [MasteryLevel.REVIEW]: 2,\n        [MasteryLevel.MASTERED]: 3\n      };\n      \n      return masteryOrder[a.masteryLevel] - masteryOrder[b.masteryLevel];\n    });\n  }\n\n  /**\n   * Calculate optimal daily review load\n   */\n  calculateDailyLoad(items: VocabularyItem[]): {\n    newItems: number;\n    reviewItems: number;\n    totalTime: number; // in minutes\n  } {\n    const dueItems = this.getDueItems(items);\n    const newItems = dueItems.filter(item => item.masteryLevel === MasteryLevel.NEW).length;\n    const reviewItems = dueItems.length - newItems;\n    \n    // Estimate time based on difficulty and mastery level\n    const totalTime = dueItems.reduce((time, item) => {\n      const baseTime = 30; // 30 seconds base\n      const difficultyMultiplier = item.difficulty / 5;\n      const masteryMultiplier = {\n        [MasteryLevel.NEW]: 1.5,\n        [MasteryLevel.LEARNING]: 1.2,\n        [MasteryLevel.REVIEW]: 1.0,\n        [MasteryLevel.MASTERED]: 0.8\n      }[item.masteryLevel];\n      \n      return time + (baseTime * difficultyMultiplier * masteryMultiplier);\n    }, 0);\n    \n    return {\n      newItems: Math.min(newItems, 20), // Cap new items\n      reviewItems,\n      totalTime: totalTime / 60 // Convert to minutes\n    };\n  }\n\n  /**\n   * Generate review session with optimal card ordering\n   */\n  generateReviewSession(\n    items: VocabularyItem[],\n    maxCards: number = 50,\n    reviewType: ReviewType = ReviewType.DAILY\n  ): VocabularyItem[] {\n    const dueItems = this.getDueItems(items);\n    \n    if (dueItems.length === 0) return [];\n    \n    // Apply different strategies based on review type\n    switch (reviewType) {\n      case ReviewType.DAILY:\n        return this.generateDailySession(dueItems, maxCards);\n      case ReviewType.OVERDUE:\n        return this.generateOverdueSession(dueItems, maxCards);\n      case ReviewType.PRACTICE:\n        return this.generatePracticeSession(items, maxCards);\n      case ReviewType.QUICK:\n        return this.generateQuickSession(dueItems, Math.min(maxCards, 10));\n      default:\n        return dueItems.slice(0, maxCards);\n    }\n  }\n\n  private generateDailySession(dueItems: VocabularyItem[], maxCards: number): VocabularyItem[] {\n    // Balance new items and reviews\n    const newItems = dueItems.filter(item => item.masteryLevel === MasteryLevel.NEW);\n    const reviewItems = dueItems.filter(item => item.masteryLevel !== MasteryLevel.NEW);\n    \n    const maxNewItems = Math.min(Math.floor(maxCards * 0.3), 15);\n    const maxReviewItems = maxCards - maxNewItems;\n    \n    return [\n      ...newItems.slice(0, maxNewItems),\n      ...reviewItems.slice(0, maxReviewItems)\n    ];\n  }\n\n  private generateOverdueSession(dueItems: VocabularyItem[], maxCards: number): VocabularyItem[] {\n    // Focus on most overdue items\n    const now = new Date();\n    return dueItems\n      .sort((a, b) => {\n        const aOverdue = a.nextReviewAt ? now.getTime() - new Date(a.nextReviewAt).getTime() : 0;\n        const bOverdue = b.nextReviewAt ? now.getTime() - new Date(b.nextReviewAt).getTime() : 0;\n        return bOverdue - aOverdue;\n      })\n      .slice(0, maxCards);\n  }\n\n  private generatePracticeSession(allItems: VocabularyItem[], maxCards: number): VocabularyItem[] {\n    // Include items that need reinforcement (low accuracy, recent mistakes)\n    const candidates = allItems.filter(item => {\n      const accuracy = item.timesReviewed > 0 ? item.timesCorrect / item.timesReviewed : 1;\n      return accuracy < 0.8 || item.streak < 3;\n    });\n    \n    return this.shuffleArray(candidates).slice(0, maxCards);\n  }\n\n  private generateQuickSession(dueItems: VocabularyItem[], maxCards: number): VocabularyItem[] {\n    // Focus on easiest items for quick wins\n    return dueItems\n      .sort((a, b) => {\n        const aScore = a.difficulty + (4 - Object.values(MasteryLevel).indexOf(a.masteryLevel));\n        const bScore = b.difficulty + (4 - Object.values(MasteryLevel).indexOf(b.masteryLevel));\n        return aScore - bScore;\n      })\n      .slice(0, maxCards);\n  }\n\n  /**\n   * Analyze user performance and suggest adjustments\n   */\n  analyzePerformance(sessions: SRSReviewSession[]): {\n    averageAccuracy: number;\n    recommendedDailyGoal: number;\n    difficultyTrend: 'increasing' | 'stable' | 'decreasing';\n    suggestions: string[];\n  } {\n    if (sessions.length === 0) {\n      return {\n        averageAccuracy: 0,\n        recommendedDailyGoal: 10,\n        difficultyTrend: 'stable',\n        suggestions: ['Complete your first review session to get personalized recommendations.']\n      };\n    }\n    \n    const recentSessions = sessions.slice(-10); // Last 10 sessions\n    const avgAccuracy = recentSessions.reduce((sum, s) => sum + s.accuracy, 0) / recentSessions.length;\n    \n    // Calculate recommended daily goal based on performance\n    let recommendedGoal = 20;\n    if (avgAccuracy > 0.9) recommendedGoal = 30;\n    else if (avgAccuracy > 0.8) recommendedGoal = 25;\n    else if (avgAccuracy < 0.6) recommendedGoal = 15;\n    \n    // Analyze difficulty trend\n    const difficultyTrend = this.analyzeDifficultyTrend(recentSessions);\n    \n    // Generate suggestions\n    const suggestions = this.generateSuggestions(avgAccuracy, difficultyTrend, recentSessions);\n    \n    return {\n      averageAccuracy: avgAccuracy,\n      recommendedDailyGoal: recommendedGoal,\n      difficultyTrend,\n      suggestions\n    };\n  }\n\n  private analyzeDifficultyTrend(sessions: SRSReviewSession[]): 'increasing' | 'stable' | 'decreasing' {\n    if (sessions.length < 3) return 'stable';\n    \n    const recent = sessions.slice(-3).map(s => s.accuracy);\n    const trend = recent[2] - recent[0];\n    \n    if (trend > 0.1) return 'increasing';\n    if (trend < -0.1) return 'decreasing';\n    return 'stable';\n  }\n\n  private generateSuggestions(accuracy: number, trend: string, sessions: SRSReviewSession[]): string[] {\n    const suggestions: string[] = [];\n    \n    if (accuracy < 0.6) {\n      suggestions.push('Consider reducing daily goal to focus on quality over quantity.');\n      suggestions.push('Review words multiple times throughout the day in shorter sessions.');\n    }\n    \n    if (accuracy > 0.9 && trend === 'increasing') {\n      suggestions.push('Great job! You can increase your daily goal or add more challenging words.');\n    }\n    \n    if (trend === 'decreasing') {\n      suggestions.push('Take a short break or review fundamentals to regain momentum.');\n    }\n    \n    const avgSessionTime = sessions.reduce((sum, s) => sum + s.duration, 0) / sessions.length;\n    if (avgSessionTime > 30 * 60 * 1000) { // 30 minutes\n      suggestions.push('Consider breaking long sessions into shorter, more frequent ones.');\n    }\n    \n    return suggestions;\n  }\n\n  // Utility methods\n  private addDaysToDate(date: Date, days: number): Date {\n    const result = new Date(date);\n    result.setDate(result.getDate() + days);\n    return result;\n  }\n\n  private shuffleArray<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n}\n\n// Export singleton instance\nexport const srsService = new SRSService();\n\n// Export class for custom configurations\nexport { SRSService };