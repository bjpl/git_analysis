import React from 'react';\nimport { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '../utils/testUtils';\nimport userEvent from '@testing-library/user-event';\nimport { server } from '../mocks/server';\nimport { http, HttpResponse } from 'msw';\nimport { mockUnsplashResponse, mockAIDescriptionResponse } from '../mocks/mockData';\nimport App from '../../src/App';\n\n// Mock environment variables\nprocess.env.VITE_SUPABASE_URL = 'https://test.supabase.co';\nprocess.env.VITE_SUPABASE_ANON_KEY = 'test-anon-key';\nprocess.env.VITE_UNSPLASH_ACCESS_KEY = 'test-unsplash-key';\n\ndescribe('Image Search Workflow Integration', () => {\n  beforeEach(() => {\n    // Reset handlers before each test\n    server.resetHandlers();\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should complete full image search and description generation workflow', async () => {\n    const user = userEvent.setup();\n    \n    // Mock successful responses\n    server.use(\n      http.get('https://api.unsplash.com/search/photos', ({ request }) => {\n        const url = new URL(request.url);\n        const query = url.searchParams.get('query');\n        return HttpResponse.json(mockUnsplashResponse(query || 'test'));\n      }),\n      \n      http.post('https://api.openai.com/v1/chat/completions', () => {\n        return HttpResponse.json(mockAIDescriptionResponse('beach scene'));\n      })\n    );\n\n    render(<App />);\n\n    // Wait for app to initialize\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    // Step 1: Search for images\n    const searchInput = screen.getByRole('searchbox');\n    await user.type(searchInput, 'beach');\n    \n    const searchButton = screen.getByRole('button', { name: /search/i });\n    await user.click(searchButton);\n\n    // Step 2: Wait for search results\n    await waitFor(() => {\n      expect(screen.getByText('Search Results')).toBeInTheDocument();\n    }, { timeout: 5000 });\n\n    // Verify images are displayed\n    const images = screen.getAllByRole('img');\n    expect(images.length).toBeGreaterThan(0);\n\n    // Step 3: Select an image\n    const firstImageCard = screen.getAllByTestId('image-card')[0];\n    await user.click(firstImageCard);\n\n    // Step 4: Wait for image to be selected and description generation to start\n    await waitFor(() => {\n      expect(screen.getByTestId('selected-image')).toBeInTheDocument();\n    });\n\n    // Step 5: Generate AI description\n    const generateButton = screen.getByRole('button', { name: /generate description/i });\n    await user.click(generateButton);\n\n    // Step 6: Wait for description to be generated\n    await waitFor(() => {\n      expect(screen.getByTestId('ai-description')).toBeInTheDocument();\n    }, { timeout: 10000 });\n\n    // Verify description content\n    const descriptionText = screen.getByTestId('ai-description');\n    expect(descriptionText).toHaveTextContent(/playa|beach/i);\n\n    // Step 7: Extract and display vocabulary\n    await waitFor(() => {\n      expect(screen.getByTestId('vocabulary-list')).toBeInTheDocument();\n    });\n\n    const vocabularyItems = screen.getAllByTestId('vocabulary-item');\n    expect(vocabularyItems.length).toBeGreaterThan(0);\n  });\n\n  it('should handle search errors gracefully', async () => {\n    const user = userEvent.setup();\n    \n    // Mock API error\n    server.use(\n      http.get('https://api.unsplash.com/search/photos', () => {\n        return HttpResponse.json(\n          { errors: ['Rate limit exceeded'] },\n          { status: 429 }\n        );\n      })\n    );\n\n    render(<App />);\n\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    const searchInput = screen.getByRole('searchbox');\n    await user.type(searchInput, 'mountains');\n    \n    const searchButton = screen.getByRole('button', { name: /search/i });\n    await user.click(searchButton);\n\n    // Should show error message\n    await waitFor(() => {\n      expect(screen.getByTestId('error-message')).toBeInTheDocument();\n    });\n\n    expect(screen.getByText(/rate limit exceeded/i)).toBeInTheDocument();\n  });\n\n  it('should handle offline scenario', async () => {\n    const user = userEvent.setup();\n    \n    // Mock network error\n    server.use(\n      http.get('https://api.unsplash.com/search/photos', () => {\n        return HttpResponse.error();\n      })\n    );\n\n    render(<App />);\n\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    const searchInput = screen.getByRole('searchbox');\n    await user.type(searchInput, 'nature');\n    \n    const searchButton = screen.getByRole('button', { name: /search/i });\n    await user.click(searchButton);\n\n    // Should show offline indicator\n    await waitFor(() => {\n      expect(screen.getByTestId('offline-indicator')).toBeInTheDocument();\n    });\n  });\n\n  it('should save vocabulary to user account when logged in', async () => {\n    const user = userEvent.setup();\n    let savedVocabulary = null;\n    \n    // Mock authenticated state\n    server.use(\n      http.get('https://test.supabase.co/auth/v1/user', () => {\n        return HttpResponse.json({\n          id: 'user-123',\n          email: 'test@example.com',\n        });\n      }),\n      \n      http.get('https://api.unsplash.com/search/photos', ({ request }) => {\n        const url = new URL(request.url);\n        const query = url.searchParams.get('query');\n        return HttpResponse.json(mockUnsplashResponse(query || 'test'));\n      }),\n      \n      http.post('https://api.openai.com/v1/chat/completions', () => {\n        return HttpResponse.json(mockAIDescriptionResponse('sunset scene'));\n      }),\n      \n      http.post('https://test.supabase.co/rest/v1/vocabulary', async ({ request }) => {\n        const body = await request.json();\n        savedVocabulary = body;\n        return HttpResponse.json({ id: 'vocab-new', ...body }, { status: 201 });\n      })\n    );\n\n    render(<App />);\n\n    // Complete search workflow\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    const searchInput = screen.getByRole('searchbox');\n    await user.type(searchInput, 'sunset');\n    \n    const searchButton = screen.getByRole('button', { name: /search/i });\n    await user.click(searchButton);\n\n    await waitFor(() => {\n      expect(screen.getAllByTestId('image-card').length).toBeGreaterThan(0);\n    });\n\n    const firstImageCard = screen.getAllByTestId('image-card')[0];\n    await user.click(firstImageCard);\n\n    const generateButton = screen.getByRole('button', { name: /generate description/i });\n    await user.click(generateButton);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('vocabulary-list')).toBeInTheDocument();\n    });\n\n    // Click on vocabulary item to add to collection\n    const vocabularyItem = screen.getAllByTestId('vocabulary-item')[0];\n    await user.click(vocabularyItem);\n\n    // Wait for save to complete\n    await waitFor(() => {\n      expect(savedVocabulary).toBeTruthy();\n    });\n\n    expect(savedVocabulary).toMatchObject({\n      user_id: 'user-123',\n      spanish_word: expect.any(String),\n      english_translation: expect.any(String),\n    });\n  });\n\n  it('should handle pagination in search results', async () => {\n    const user = userEvent.setup();\n    \n    server.use(\n      http.get('https://api.unsplash.com/search/photos', ({ request }) => {\n        const url = new URL(request.url);\n        const query = url.searchParams.get('query');\n        const page = parseInt(url.searchParams.get('page') || '1');\n        \n        return HttpResponse.json(mockUnsplashResponse(query || 'test', page, 10));\n      })\n    );\n\n    render(<App />);\n\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    const searchInput = screen.getByRole('searchbox');\n    await user.type(searchInput, 'forest');\n    \n    const searchButton = screen.getByRole('button', { name: /search/i });\n    await user.click(searchButton);\n\n    await waitFor(() => {\n      expect(screen.getAllByTestId('image-card').length).toBe(10);\n    });\n\n    // Load more results\n    const loadMoreButton = screen.getByRole('button', { name: /load more/i });\n    await user.click(loadMoreButton);\n\n    await waitFor(() => {\n      expect(screen.getAllByTestId('image-card').length).toBe(20);\n    });\n  });\n\n  it('should handle real-time vocabulary sync', async () => {\n    const user = userEvent.setup();\n    \n    render(<App />);\n\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    // Navigate to vocabulary page\n    const vocabularyLink = screen.getByRole('link', { name: /vocabulary/i });\n    await user.click(vocabularyLink);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('vocabulary-page')).toBeInTheDocument();\n    });\n\n    // Verify vocabulary list loads\n    await waitFor(() => {\n      expect(screen.getByTestId('vocabulary-list')).toBeInTheDocument();\n    });\n\n    const vocabularyItems = screen.getAllByTestId('vocabulary-item');\n    expect(vocabularyItems.length).toBeGreaterThan(0);\n  });\n\n  it('should support keyboard navigation throughout workflow', async () => {\n    const user = userEvent.setup();\n    \n    server.use(\n      http.get('https://api.unsplash.com/search/photos', ({ request }) => {\n        const url = new URL(request.url);\n        const query = url.searchParams.get('query');\n        return HttpResponse.json(mockUnsplashResponse(query || 'test'));\n      })\n    );\n\n    render(<App />);\n\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    // Use keyboard to navigate and search\n    const searchInput = screen.getByRole('searchbox');\n    await user.type(searchInput, 'wildlife');\n    await user.keyboard('{Enter}');\n\n    await waitFor(() => {\n      expect(screen.getAllByTestId('image-card').length).toBeGreaterThan(0);\n    });\n\n    // Use keyboard to select first image\n    const firstImageCard = screen.getAllByTestId('image-card')[0];\n    firstImageCard.focus();\n    await user.keyboard('{Enter}');\n\n    await waitFor(() => {\n      expect(screen.getByTestId('selected-image')).toBeInTheDocument();\n    });\n\n    // Use keyboard to generate description\n    const generateButton = screen.getByRole('button', { name: /generate description/i });\n    generateButton.focus();\n    await user.keyboard(' '); // Space key\n\n    await waitFor(() => {\n      expect(screen.getByTestId('ai-description')).toBeInTheDocument();\n    });\n  });\n\n  it('should handle concurrent searches', async () => {\n    const user = userEvent.setup();\n    let requestCount = 0;\n    \n    server.use(\n      http.get('https://api.unsplash.com/search/photos', async ({ request }) => {\n        requestCount++;\n        const url = new URL(request.url);\n        const query = url.searchParams.get('query');\n        \n        // Simulate delay for first request\n        if (requestCount === 1) {\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n        \n        return HttpResponse.json(mockUnsplashResponse(query || 'test'));\n      })\n    );\n\n    render(<App />);\n\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    const searchInput = screen.getByRole('searchbox');\n    const searchButton = screen.getByRole('button', { name: /search/i });\n\n    // Start first search\n    await user.type(searchInput, 'mountains');\n    await user.click(searchButton);\n\n    // Quickly start second search\n    await user.clear(searchInput);\n    await user.type(searchInput, 'ocean');\n    await user.click(searchButton);\n\n    // Should only show results for the latest search\n    await waitFor(() => {\n      expect(screen.getByText('Search Results')).toBeInTheDocument();\n    });\n\n    // Should have canceled the first request and only processed the second\n    expect(requestCount).toBe(2);\n  });\n\n  it('should persist search state across page refreshes', async () => {\n    const user = userEvent.setup();\n    \n    server.use(\n      http.get('https://api.unsplash.com/search/photos', ({ request }) => {\n        const url = new URL(request.url);\n        const query = url.searchParams.get('query');\n        return HttpResponse.json(mockUnsplashResponse(query || 'test'));\n      })\n    );\n\n    render(<App />);\n\n    await waitFor(() => {\n      expect(screen.getByRole('searchbox')).toBeInTheDocument();\n    });\n\n    // Perform search\n    const searchInput = screen.getByRole('searchbox');\n    await user.type(searchInput, 'architecture');\n    \n    const searchButton = screen.getByRole('button', { name: /search/i });\n    await user.click(searchButton);\n\n    await waitFor(() => {\n      expect(screen.getAllByTestId('image-card').length).toBeGreaterThan(0);\n    });\n\n    // Simulate page refresh by re-rendering\n    const { rerender } = render(<App />);\n    \n    // Search term should be restored from localStorage/URL\n    await waitFor(() => {\n      const restoredSearchInput = screen.getByRole('searchbox') as HTMLInputElement;\n      expect(restoredSearchInput.value).toBe('architecture');\n    });\n  });\n});"