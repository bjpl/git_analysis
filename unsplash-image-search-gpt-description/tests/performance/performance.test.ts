import { test, expect, devices } from '@playwright/test';\n\ntest.describe('VocabLens Performance Tests', () => {\n  // Performance thresholds\n  const PERFORMANCE_THRESHOLDS = {\n    FCP: 2000,     // First Contentful Paint\n    LCP: 4000,     // Largest Contentful Paint\n    CLS: 0.1,      // Cumulative Layout Shift\n    TBT: 500,      // Total Blocking Time\n    TTI: 6000,     // Time to Interactive\n    BUNDLE_SIZE: 500 * 1024, // 500KB\n  };\n\n  test('Homepage performance metrics', async ({ page }) => {\n    // Enable performance monitoring\n    const performanceObserver = await page.evaluateHandle(() => {\n      return new Promise((resolve) => {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          resolve(entries);\n        });\n        observer.observe({ entryTypes: ['navigation', 'paint', 'largest-contentful-paint'] });\n      });\n    });\n\n    // Navigate to homepage\n    const startTime = Date.now();\n    await page.goto('/', { waitUntil: 'networkidle' });\n    const loadTime = Date.now() - startTime;\n\n    // Get performance metrics\n    const performanceEntries = await performanceObserver.jsonValue();\n    \n    // Test First Contentful Paint\n    const fcpEntries = performanceEntries.filter(entry => entry.name === 'first-contentful-paint');\n    if (fcpEntries.length > 0) {\n      const fcp = fcpEntries[0].startTime;\n      expect(fcp).toBeLessThan(PERFORMANCE_THRESHOLDS.FCP);\n      console.log(`âœ… First Contentful Paint: ${fcp.toFixed(2)}ms`);\n    }\n\n    // Test Largest Contentful Paint\n    const lcpEntries = performanceEntries.filter(entry => entry.entryType === 'largest-contentful-paint');\n    if (lcpEntries.length > 0) {\n      const lcp = lcpEntries[lcpEntries.length - 1].startTime;\n      expect(lcp).toBeLessThan(PERFORMANCE_THRESHOLDS.LCP);\n      console.log(`âœ… Largest Contentful Paint: ${lcp.toFixed(2)}ms`);\n    }\n\n    // Test overall load time\n    expect(loadTime).toBeLessThan(PERFORMANCE_THRESHOLDS.TTI);\n    console.log(`âœ… Total load time: ${loadTime}ms`);\n  });\n\n  test('JavaScript bundle size analysis', async ({ page }) => {\n    const networkRequests = [];\n\n    // Monitor network requests\n    page.on('response', response => {\n      networkRequests.push({\n        url: response.url(),\n        status: response.status(),\n        size: response.headers()['content-length'],\n        type: response.request().resourceType()\n      });\n    });\n\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n\n    // Analyze JavaScript bundles\n    const jsRequests = networkRequests.filter(req => \n      req.type === 'script' && req.url.includes('.js')\n    );\n\n    let totalJSSize = 0;\n    for (const request of jsRequests) {\n      if (request.size) {\n        totalJSSize += parseInt(request.size, 10);\n      }\n    }\n\n    console.log(`ðŸ“¦ Total JavaScript bundle size: ${(totalJSSize / 1024).toFixed(2)}KB`);\n    console.log(`ðŸ“‹ Number of JS files: ${jsRequests.length}`);\n    \n    // Test bundle size threshold\n    expect(totalJSSize).toBeLessThan(PERFORMANCE_THRESHOLDS.BUNDLE_SIZE);\n\n    // Log largest bundles for optimization insights\n    const largestBundles = jsRequests\n      .filter(req => req.size)\n      .sort((a, b) => parseInt(b.size, 10) - parseInt(a.size, 10))\n      .slice(0, 5);\n\n    console.log('ðŸ“Š Largest JavaScript bundles:');\n    largestBundles.forEach((bundle, index) => {\n      const sizeKB = (parseInt(bundle.size, 10) / 1024).toFixed(2);\n      console.log(`  ${index + 1}. ${bundle.url.split('/').pop()}: ${sizeKB}KB`);\n    });\n  });\n\n  test('Image search performance', async ({ page }) => {\n    await page.goto('/');\n    \n    // Wait for app to be ready\n    await page.waitForSelector('[data-testid=\"app-loaded\"]');\n\n    const searchBox = page.getByRole('searchbox');\n    \n    // Measure search interaction performance\n    const startTime = Date.now();\n    \n    await searchBox.fill('beach sunset');\n    await page.getByRole('button', { name: /search/i }).click();\n    \n    // Wait for results to appear\n    await page.waitForSelector('[data-testid=\"image-results\"]', { state: 'visible' });\n    \n    const searchTime = Date.now() - startTime;\n    console.log(`ðŸ” Search response time: ${searchTime}ms`);\n    \n    // Search should be reasonably fast\n    expect(searchTime).toBeLessThan(5000);\n\n    // Measure image loading performance\n    const imageLoadStartTime = Date.now();\n    \n    // Wait for first image to load\n    const firstImage = page.getByTestId('image-card').first().locator('img');\n    await expect(firstImage).toBeVisible();\n    \n    const imageLoadTime = Date.now() - imageLoadStartTime;\n    console.log(`ðŸ–¼ï¸  First image load time: ${imageLoadTime}ms`);\n    \n    expect(imageLoadTime).toBeLessThan(3000);\n  });\n\n  test('AI description generation performance', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForSelector('[data-testid=\"app-loaded\"]');\n\n    // Perform search first\n    const searchBox = page.getByRole('searchbox');\n    await searchBox.fill('mountain landscape');\n    await page.getByRole('button', { name: /search/i }).click();\n    \n    await page.waitForSelector('[data-testid=\"image-results\"]', { state: 'visible' });\n    \n    // Select first image\n    await page.getByTestId('image-card').first().click();\n    await page.waitForSelector('[data-testid=\"selected-image-preview\"]', { state: 'visible' });\n\n    // Measure AI description generation time\n    const startTime = Date.now();\n    \n    await page.getByRole('button', { name: /generate description/i }).click();\n    \n    // Wait for description to be generated\n    await page.waitForSelector('[data-testid=\"ai-description\"]', { \n      state: 'visible',\n      timeout: 30000 \n    });\n    \n    const generationTime = Date.now() - startTime;\n    console.log(`ðŸ¤– AI description generation time: ${generationTime}ms`);\n    \n    // AI generation should complete within reasonable time\n    expect(generationTime).toBeLessThan(15000);\n\n    // Verify vocabulary extraction happens quickly\n    await page.waitForSelector('[data-testid=\"vocabulary-section\"]', {\n      state: 'visible',\n      timeout: 5000\n    });\n  });\n\n  test('Memory usage and leak detection', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForSelector('[data-testid=\"app-loaded\"]');\n\n    // Get initial memory usage\n    const initialMemory = await page.evaluate(() => {\n      return (performance as any).memory?.usedJSHeapSize || 0;\n    });\n\n    // Perform multiple searches to test for memory leaks\n    const searches = ['beach', 'mountain', 'forest', 'city', 'sunset'];\n    \n    for (const searchTerm of searches) {\n      const searchBox = page.getByRole('searchbox');\n      await searchBox.fill('');\n      await searchBox.fill(searchTerm);\n      await page.getByRole('button', { name: /search/i }).click();\n      \n      await page.waitForSelector('[data-testid=\"image-results\"]', { state: 'visible' });\n      \n      // Select and generate description for each search\n      await page.getByTestId('image-card').first().click();\n      await page.getByRole('button', { name: /generate description/i }).click();\n      await page.waitForSelector('[data-testid=\"ai-description\"]', { state: 'visible' });\n      \n      // Force garbage collection if available\n      await page.evaluate(() => {\n        if ((window as any).gc) {\n          (window as any).gc();\n        }\n      });\n    }\n\n    // Check final memory usage\n    const finalMemory = await page.evaluate(() => {\n      return (performance as any).memory?.usedJSHeapSize || 0;\n    });\n\n    if (initialMemory && finalMemory) {\n      const memoryIncrease = finalMemory - initialMemory;\n      const memoryIncreasePercent = (memoryIncrease / initialMemory) * 100;\n      \n      console.log(`ðŸ’¾ Initial memory: ${(initialMemory / 1024 / 1024).toFixed(2)}MB`);\n      console.log(`ðŸ’¾ Final memory: ${(finalMemory / 1024 / 1024).toFixed(2)}MB`);\n      console.log(`ðŸ’¾ Memory increase: ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB (${memoryIncreasePercent.toFixed(2)}%)`);\n      \n      // Memory increase should be reasonable (less than 50% increase)\n      expect(memoryIncreasePercent).toBeLessThan(50);\n    }\n  });\n\n  test('Mobile performance', async ({ browser }) => {\n    const context = await browser.newContext({\n      ...devices['iPhone 12'],\n      // Simulate slower mobile network\n      extraHTTPHeaders: {\n        'User-Agent': devices['iPhone 12'].userAgent,\n      },\n    });\n\n    const page = await context.newPage();\n    \n    // Simulate mobile network conditions\n    const client = await page.context().newCDPSession(page);\n    await client.send('Network.emulateNetworkConditions', {\n      offline: false,\n      downloadThroughput: 1.5 * 1024 * 1024 / 8, // 1.5 Mbps\n      uploadThroughput: 750 * 1024 / 8, // 750 Kbps\n      latency: 40,\n    });\n\n    const startTime = Date.now();\n    await page.goto('/', { waitUntil: 'networkidle' });\n    const mobileLoadTime = Date.now() - startTime;\n\n    console.log(`ðŸ“± Mobile load time: ${mobileLoadTime}ms`);\n    \n    // Mobile should load within reasonable time even on slower connections\n    expect(mobileLoadTime).toBeLessThan(8000);\n\n    // Test mobile-specific interactions\n    await page.waitForSelector('[data-testid=\"app-loaded\"]');\n    \n    // Test touch interactions\n    const searchBox = page.getByRole('searchbox');\n    await searchBox.tap();\n    await searchBox.fill('nature');\n    \n    const searchButton = page.getByRole('button', { name: /search/i });\n    await searchButton.tap();\n    \n    await page.waitForSelector('[data-testid=\"image-results\"]', { state: 'visible' });\n    \n    // Test image card tap\n    await page.getByTestId('image-card').first().tap();\n    await page.waitForSelector('[data-testid=\"selected-image-preview\"]', { state: 'visible' });\n\n    await context.close();\n  });\n\n  test('Concurrent user simulation', async ({ browser }) => {\n    // Simulate multiple concurrent users\n    const concurrentUsers = 5;\n    const contexts = [];\n    const pages = [];\n\n    // Create multiple browser contexts\n    for (let i = 0; i < concurrentUsers; i++) {\n      const context = await browser.newContext();\n      const page = await context.newPage();\n      contexts.push(context);\n      pages.push(page);\n    }\n\n    // Simulate concurrent usage\n    const userActions = pages.map(async (page, index) => {\n      const startTime = Date.now();\n      \n      await page.goto('/');\n      await page.waitForSelector('[data-testid=\"app-loaded\"]');\n      \n      // Each user performs different search\n      const searchTerms = ['beach', 'mountain', 'forest', 'city', 'sunset'];\n      const searchTerm = searchTerms[index];\n      \n      const searchBox = page.getByRole('searchbox');\n      await searchBox.fill(searchTerm);\n      await page.getByRole('button', { name: /search/i }).click();\n      \n      await page.waitForSelector('[data-testid=\"image-results\"]', { state: 'visible' });\n      \n      const endTime = Date.now();\n      return {\n        user: index + 1,\n        searchTerm,\n        loadTime: endTime - startTime\n      };\n    });\n\n    // Wait for all users to complete their actions\n    const results = await Promise.all(userActions);\n    \n    // Analyze concurrent performance\n    const avgLoadTime = results.reduce((sum, result) => sum + result.loadTime, 0) / results.length;\n    const maxLoadTime = Math.max(...results.map(r => r.loadTime));\n    const minLoadTime = Math.min(...results.map(r => r.loadTime));\n    \n    console.log(`ðŸ‘¥ Concurrent users: ${concurrentUsers}`);\n    console.log(`ðŸ“Š Average load time: ${avgLoadTime.toFixed(2)}ms`);\n    console.log(`ðŸ“Š Min load time: ${minLoadTime}ms`);\n    console.log(`ðŸ“Š Max load time: ${maxLoadTime}ms`);\n    \n    // Performance should not degrade significantly under concurrent load\n    expect(avgLoadTime).toBeLessThan(10000);\n    expect(maxLoadTime).toBeLessThan(15000);\n    \n    // Clean up\n    for (const context of contexts) {\n      await context.close();\n    }\n  });\n\n  test('Caching effectiveness', async ({ page }) => {\n    // First visit - everything should be fresh\n    const firstVisitStart = Date.now();\n    await page.goto('/');\n    await page.waitForSelector('[data-testid=\"app-loaded\"]');\n    const firstVisitTime = Date.now() - firstVisitStart;\n    \n    // Perform a search to populate cache\n    const searchBox = page.getByRole('searchbox');\n    await searchBox.fill('landscape');\n    await page.getByRole('button', { name: /search/i }).click();\n    await page.waitForSelector('[data-testid=\"image-results\"]', { state: 'visible' });\n    \n    // Second visit - should use cache\n    const secondVisitStart = Date.now();\n    await page.reload({ waitUntil: 'networkidle' });\n    await page.waitForSelector('[data-testid=\"app-loaded\"]');\n    const secondVisitTime = Date.now() - secondVisitStart;\n    \n    console.log(`ðŸ”„ First visit: ${firstVisitTime}ms`);\n    console.log(`ðŸ”„ Second visit (cached): ${secondVisitTime}ms`);\n    \n    // Second visit should be significantly faster due to caching\n    const improvement = ((firstVisitTime - secondVisitTime) / firstVisitTime) * 100;\n    console.log(`ðŸ“ˆ Cache improvement: ${improvement.toFixed(2)}%`);\n    \n    expect(secondVisitTime).toBeLessThan(firstVisitTime);\n    expect(improvement).toBeGreaterThan(10); // At least 10% improvement\n  });\n});"