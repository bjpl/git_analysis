import { renderHook, waitFor, act } from '@testing-library/react';\nimport { vi, describe, it, expect, beforeEach } from 'vitest';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { useVocabulary } from '../../../src/hooks/useVocabulary';\nimport { mockVocabularyEntries, createMockVocabularyEntry } from '../../utils/testUtils';\n\n// Mock Supabase\nconst mockSupabase = {\n  from: vi.fn(() => ({\n    select: vi.fn().mockReturnThis(),\n    insert: vi.fn().mockReturnThis(),\n    update: vi.fn().mockReturnThis(),\n    delete: vi.fn().mockReturnThis(),\n    eq: vi.fn().mockReturnThis(),\n    order: vi.fn().mockReturnThis(),\n    limit: vi.fn().mockReturnThis(),\n  })),\n};\n\nvi.mock('../../../src/lib/supabase', () => ({\n  supabase: mockSupabase,\n}));\n\nconst createWrapper = () => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n      mutations: { retry: false },\n    },\n  });\n\n  return ({ children }: { children: React.ReactNode }) => (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  );\n};\n\ndescribe('useVocabulary', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n    \n    // Setup default successful response\n    mockSupabase.from.mockReturnValue({\n      select: vi.fn().mockReturnThis(),\n      insert: vi.fn().mockReturnThis(),\n      update: vi.fn().mockReturnThis(),\n      delete: vi.fn().mockReturnThis(),\n      eq: vi.fn().mockReturnThis(),\n      order: vi.fn().mockReturnThis(),\n      limit: vi.fn().mockReturnThis(),\n      then: vi.fn((callback) => callback({ data: mockVocabularyEntries, error: null })),\n    });\n  });\n\n  it('should fetch vocabulary entries successfully', async () => {\n    const { result } = renderHook(() => useVocabulary('user-123'), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    expect(result.current.data).toEqual(mockVocabularyEntries);\n    expect(result.current.isError).toBe(false);\n  });\n\n  it('should handle fetch errors', async () => {\n    const mockError = new Error('Database error');\n    \n    mockSupabase.from.mockReturnValue({\n      select: vi.fn().mockReturnThis(),\n      eq: vi.fn().mockReturnThis(),\n      order: vi.fn().mockReturnThis(),\n      limit: vi.fn().mockReturnThis(),\n      then: vi.fn((callback) => callback({ data: null, error: mockError })),\n    });\n\n    const { result } = renderHook(() => useVocabulary('user-123'), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isError).toBe(true);\n    });\n\n    expect(result.current.error).toBeDefined();\n    expect(result.current.data).toBeUndefined();\n  });\n\n  it('should add vocabulary entry successfully', async () => {\n    const newEntry = createMockVocabularyEntry({\n      spanish_word: 'nuevo',\n      english_translation: 'new',\n    });\n\n    const mockInsert = vi.fn().mockReturnValue({\n      then: vi.fn((callback) => callback({ data: [newEntry], error: null })),\n    });\n\n    mockSupabase.from.mockReturnValue({\n      insert: mockInsert,\n      select: vi.fn().mockReturnThis(),\n      eq: vi.fn().mockReturnThis(),\n      order: vi.fn().mockReturnThis(),\n      limit: vi.fn().mockReturnThis(),\n      then: vi.fn((callback) => callback({ data: mockVocabularyEntries, error: null })),\n    });\n\n    const { result } = renderHook(() => useVocabulary('user-123'), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    await act(async () => {\n      await result.current.addEntry({\n        spanish_word: 'nuevo',\n        english_translation: 'new',\n        context: 'Un día nuevo',\n        difficulty_level: 'beginner',\n      });\n    });\n\n    expect(mockInsert).toHaveBeenCalledWith({\n      user_id: 'user-123',\n      spanish_word: 'nuevo',\n      english_translation: 'new',\n      context: 'Un día nuevo',\n      difficulty_level: 'beginner',\n      mastery_level: 0,\n      times_reviewed: 0,\n    });\n  });\n\n  it('should update vocabulary entry successfully', async () => {\n    const updatedEntry = {\n      ...mockVocabularyEntries[0],\n      mastery_level: 4,\n      times_reviewed: 10,\n    };\n\n    const mockUpdate = vi.fn().mockReturnValue({\n      eq: vi.fn().mockReturnThis(),\n      then: vi.fn((callback) => callback({ data: [updatedEntry], error: null })),\n    });\n\n    mockSupabase.from.mockReturnValue({\n      update: mockUpdate,\n      select: vi.fn().mockReturnThis(),\n      eq: vi.fn().mockReturnThis(),\n      order: vi.fn().mockReturnThis(),\n      limit: vi.fn().mockReturnThis(),\n      then: vi.fn((callback) => callback({ data: mockVocabularyEntries, error: null })),\n    });\n\n    const { result } = renderHook(() => useVocabulary('user-123'), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    await act(async () => {\n      await result.current.updateEntry('vocab-1', {\n        mastery_level: 4,\n        times_reviewed: 10,\n      });\n    });\n\n    expect(mockUpdate).toHaveBeenCalledWith({\n      mastery_level: 4,\n      times_reviewed: 10,\n      updated_at: expect.any(String),\n    });\n  });\n\n  it('should delete vocabulary entry successfully', async () => {\n    const mockDelete = vi.fn().mockReturnValue({\n      eq: vi.fn().mockReturnThis(),\n      then: vi.fn((callback) => callback({ data: null, error: null })),\n    });\n\n    mockSupabase.from.mockReturnValue({\n      delete: mockDelete,\n      select: vi.fn().mockReturnThis(),\n      eq: vi.fn().mockReturnThis(),\n      order: vi.fn().mockReturnThis(),\n      limit: vi.fn().mockReturnThis(),\n      then: vi.fn((callback) => callback({ data: mockVocabularyEntries, error: null })),\n    });\n\n    const { result } = renderHook(() => useVocabulary('user-123'), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    await act(async () => {\n      await result.current.deleteEntry('vocab-1');\n    });\n\n    expect(mockDelete).toHaveBeenCalled();\n  });\n\n  it('should filter vocabulary by difficulty level', async () => {\n    const { result } = renderHook(() => useVocabulary('user-123', { difficulty: 'beginner' }), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    const beginnerEntries = result.current.data?.filter(\n      entry => entry.difficulty_level === 'beginner'\n    );\n    expect(beginnerEntries).toHaveLength(1);\n  });\n\n  it('should search vocabulary by term', async () => {\n    const { result } = renderHook(() => useVocabulary('user-123', { search: 'playa' }), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    const searchResults = result.current.data?.filter(\n      entry => \n        entry.spanish_word.includes('playa') || \n        entry.english_translation.includes('beach')\n    );\n    expect(searchResults).toHaveLength(1);\n  });\n\n  it('should handle duplicate entries', async () => {\n    const duplicateError = new Error('Duplicate entry');\n    // @ts-ignore\n    duplicateError.code = '23505'; // PostgreSQL unique violation\n\n    const mockInsert = vi.fn().mockReturnValue({\n      then: vi.fn((callback) => callback({ data: null, error: duplicateError })),\n    });\n\n    mockSupabase.from.mockReturnValue({\n      insert: mockInsert,\n      select: vi.fn().mockReturnThis(),\n      eq: vi.fn().mockReturnThis(),\n      order: vi.fn().mockReturnThis(),\n      limit: vi.fn().mockReturnThis(),\n      then: vi.fn((callback) => callback({ data: mockVocabularyEntries, error: null })),\n    });\n\n    const { result } = renderHook(() => useVocabulary('user-123'), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    await expect(async () => {\n      await act(async () => {\n        await result.current.addEntry({\n          spanish_word: 'playa',\n          english_translation: 'beach',\n          context: 'Una playa hermosa',\n          difficulty_level: 'beginner',\n        });\n      });\n    }).rejects.toThrow('Duplicate entry');\n  });\n\n  it('should calculate mastery statistics', async () => {\n    const { result } = renderHook(() => useVocabulary('user-123'), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    const stats = result.current.getStatistics();\n    \n    expect(stats.total).toBe(mockVocabularyEntries.length);\n    expect(stats.mastered).toBe(1); // mastery_level >= 3\n    expect(stats.learning).toBe(1); // mastery_level 1-2\n    expect(stats.new).toBe(1); // mastery_level 0\n  });\n\n  it('should get entries due for review', async () => {\n    const { result } = renderHook(() => useVocabulary('user-123'), {\n      wrapper: createWrapper(),\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    const dueEntries = result.current.getDueForReview();\n    \n    // Should return entries that haven't been reviewed recently\n    expect(dueEntries).toBeInstanceOf(Array);\n    expect(dueEntries.length).toBeGreaterThanOrEqual(0);\n  });\n});"