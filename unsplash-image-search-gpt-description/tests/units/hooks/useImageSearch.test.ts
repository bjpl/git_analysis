import { renderHook, waitFor } from '@testing-library/react';\nimport { vi, describe, it, expect, beforeEach } from 'vitest';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { useImageSearch } from '../../../src/hooks/useImageSearch';\nimport { mockUnsplashResponse } from '../../mocks/mockData';\n\n// Mock the actual API call\nvi.mock('../../../src/services/unsplashService', () => ({\n  searchPhotos: vi.fn(),\n}));\n\nconst createWrapper = () => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n      mutations: { retry: false },\n    },\n  });\n\n  return ({ children }: { children: React.ReactNode }) => (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  );\n};\n\ndescribe('useImageSearch', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should return initial state correctly', () => {\n    const { result } = renderHook(() => useImageSearch(), {\n      wrapper: createWrapper(),\n    });\n\n    expect(result.current.data).toBeUndefined();\n    expect(result.current.isLoading).toBe(false);\n    expect(result.current.isError).toBe(false);\n    expect(result.current.error).toBeNull();\n  });\n\n  it('should search images successfully', async () => {\n    const mockSearchPhotos = vi.fn().mockResolvedValue(mockUnsplashResponse('test'));\n    \n    vi.doMock('../../../src/services/unsplashService', () => ({\n      searchPhotos: mockSearchPhotos,\n    }));\n\n    const { result } = renderHook(() => useImageSearch(), {\n      wrapper: createWrapper(),\n    });\n\n    // Trigger search\n    result.current.searchPhotos({\n      query: 'test',\n      page: 1,\n      perPage: 10,\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    expect(mockSearchPhotos).toHaveBeenCalledWith({\n      query: 'test',\n      page: 1,\n      perPage: 10,\n    });\n  });\n\n  it('should handle search errors', async () => {\n    const mockError = new Error('API Error');\n    const mockSearchPhotos = vi.fn().mockRejectedValue(mockError);\n    \n    vi.doMock('../../../src/services/unsplashService', () => ({\n      searchPhotos: mockSearchPhotos,\n    }));\n\n    const { result } = renderHook(() => useImageSearch(), {\n      wrapper: createWrapper(),\n    });\n\n    result.current.searchPhotos({\n      query: 'test',\n      page: 1,\n      perPage: 10,\n    });\n\n    await waitFor(() => {\n      expect(result.current.isError).toBe(true);\n    });\n\n    expect(result.current.error).toBeDefined();\n  });\n\n  it('should handle empty query', () => {\n    const { result } = renderHook(() => useImageSearch(), {\n      wrapper: createWrapper(),\n    });\n\n    // Should not trigger search with empty query\n    result.current.searchPhotos({\n      query: '',\n      page: 1,\n      perPage: 10,\n    });\n\n    expect(result.current.data).toBeUndefined();\n  });\n\n  it('should debounce search queries', async () => {\n    const mockSearchPhotos = vi.fn().mockResolvedValue(mockUnsplashResponse('test'));\n    \n    vi.doMock('../../../src/services/unsplashService', () => ({\n      searchPhotos: mockSearchPhotos,\n    }));\n\n    const { result } = renderHook(() => useImageSearch(), {\n      wrapper: createWrapper(),\n    });\n\n    // Trigger multiple searches rapidly\n    result.current.searchPhotos({ query: 'test1', page: 1, perPage: 10 });\n    result.current.searchPhotos({ query: 'test2', page: 1, perPage: 10 });\n    result.current.searchPhotos({ query: 'test3', page: 1, perPage: 10 });\n\n    await waitFor(() => {\n      expect(mockSearchPhotos).toHaveBeenCalledTimes(1);\n    });\n\n    // Should only call the last search\n    expect(mockSearchPhotos).toHaveBeenLastCalledWith({\n      query: 'test3',\n      page: 1,\n      perPage: 10,\n    });\n  });\n\n  it('should handle pagination correctly', async () => {\n    const mockResponse = mockUnsplashResponse('test', 2, 10);\n    const mockSearchPhotos = vi.fn().mockResolvedValue(mockResponse);\n    \n    vi.doMock('../../../src/services/unsplashService', () => ({\n      searchPhotos: mockSearchPhotos,\n    }));\n\n    const { result } = renderHook(() => useImageSearch(), {\n      wrapper: createWrapper(),\n    });\n\n    result.current.searchPhotos({\n      query: 'test',\n      page: 2,\n      perPage: 10,\n    });\n\n    await waitFor(() => {\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    expect(mockSearchPhotos).toHaveBeenCalledWith({\n      query: 'test',\n      page: 2,\n      perPage: 10,\n    });\n  });\n\n  it('should handle rate limiting', async () => {\n    const rateLimitError = new Error('Rate limit exceeded');\n    // @ts-ignore\n    rateLimitError.status = 429;\n    \n    const mockSearchPhotos = vi.fn().mockRejectedValue(rateLimitError);\n    \n    vi.doMock('../../../src/services/unsplashService', () => ({\n      searchPhotos: mockSearchPhotos,\n    }));\n\n    const { result } = renderHook(() => useImageSearch(), {\n      wrapper: createWrapper(),\n    });\n\n    result.current.searchPhotos({\n      query: 'test',\n      page: 1,\n      perPage: 10,\n    });\n\n    await waitFor(() => {\n      expect(result.current.isError).toBe(true);\n    });\n\n    expect(result.current.error).toBeDefined();\n    // @ts-ignore\n    expect(result.current.error.status).toBe(429);\n  });\n});"