import React from 'react';\nimport { vi, describe, it, expect, beforeEach } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '../../utils/testUtils';\nimport userEvent from '@testing-library/user-event';\nimport { SearchBar } from '../../../src/components/ImageSearch/SearchBar';\n\ndescribe('SearchBar', () => {\n  const mockOnSearch = vi.fn();\n  const mockOnClear = vi.fn();\n  const mockOnFocus = vi.fn();\n  const mockOnBlur = vi.fn();\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should render search bar with placeholder', () => {\n    render(\n      <SearchBar\n        onSearch={mockOnSearch}\n        placeholder=\"Search for images...\"\n      />\n    );\n\n    const input = screen.getByPlaceholderText('Search for images...');\n    expect(input).toBeInTheDocument();\n    expect(input).toHaveAttribute('type', 'search');\n  });\n\n  it('should call onSearch when form is submitted', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar onSearch={mockOnSearch} />\n    );\n\n    const input = screen.getByRole('searchbox');\n    const searchButton = screen.getByRole('button', { name: /search/i });\n\n    await user.type(input, 'nature');\n    await user.click(searchButton);\n\n    expect(mockOnSearch).toHaveBeenCalledWith('nature');\n  });\n\n  it('should call onSearch when Enter key is pressed', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar onSearch={mockOnSearch} />\n    );\n\n    const input = screen.getByRole('searchbox');\n    \n    await user.type(input, 'mountains');\n    await user.keyboard('{Enter}');\n\n    expect(mockOnSearch).toHaveBeenCalledWith('mountains');\n  });\n\n  it('should show loading state', () => {\n    render(\n      <SearchBar \n        onSearch={mockOnSearch} \n        isLoading={true}\n      />\n    );\n\n    expect(screen.getByTestId('search-loading')).toBeInTheDocument();\n    \n    const searchButton = screen.getByRole('button', { name: /search/i });\n    expect(searchButton).toBeDisabled();\n  });\n\n  it('should show clear button when there is text', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar onSearch={mockOnSearch} onClear={mockOnClear} />\n    );\n\n    const input = screen.getByRole('searchbox');\n    \n    await user.type(input, 'ocean');\n    \n    const clearButton = screen.getByRole('button', { name: /clear/i });\n    expect(clearButton).toBeInTheDocument();\n  });\n\n  it('should clear input when clear button is clicked', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar onSearch={mockOnSearch} onClear={mockOnClear} />\n    );\n\n    const input = screen.getByRole('searchbox') as HTMLInputElement;\n    \n    await user.type(input, 'forest');\n    expect(input.value).toBe('forest');\n    \n    const clearButton = screen.getByRole('button', { name: /clear/i });\n    await user.click(clearButton);\n    \n    expect(input.value).toBe('');\n    expect(mockOnClear).toHaveBeenCalled();\n  });\n\n  it('should not submit empty search', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar onSearch={mockOnSearch} />\n    );\n\n    const searchButton = screen.getByRole('button', { name: /search/i });\n    await user.click(searchButton);\n\n    expect(mockOnSearch).not.toHaveBeenCalled();\n  });\n\n  it('should trim whitespace from search query', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar onSearch={mockOnSearch} />\n    );\n\n    const input = screen.getByRole('searchbox');\n    const searchButton = screen.getByRole('button', { name: /search/i });\n\n    await user.type(input, '  beach  ');\n    await user.click(searchButton);\n\n    expect(mockOnSearch).toHaveBeenCalledWith('beach');\n  });\n\n  it('should show search suggestions', async () => {\n    const suggestions = ['nature', 'landscape', 'wildlife', 'forest'];\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        suggestions={suggestions}\n        showSuggestions={true}\n      />\n    );\n\n    const input = screen.getByRole('searchbox');\n    await user.type(input, 'na');\n\n    await waitFor(() => {\n      expect(screen.getByText('nature')).toBeInTheDocument();\n    });\n\n    // Should filter suggestions based on input\n    expect(screen.getByText('nature')).toBeInTheDocument();\n    expect(screen.queryByText('beach')).not.toBeInTheDocument();\n  });\n\n  it('should select suggestion when clicked', async () => {\n    const suggestions = ['nature', 'landscape', 'wildlife'];\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        suggestions={suggestions}\n        showSuggestions={true}\n      />\n    );\n\n    const input = screen.getByRole('searchbox') as HTMLInputElement;\n    await user.type(input, 'na');\n\n    await waitFor(() => {\n      expect(screen.getByText('nature')).toBeInTheDocument();\n    });\n\n    const suggestion = screen.getByText('nature');\n    await user.click(suggestion);\n\n    expect(input.value).toBe('nature');\n    expect(mockOnSearch).toHaveBeenCalledWith('nature');\n  });\n\n  it('should navigate suggestions with keyboard', async () => {\n    const suggestions = ['nature', 'landscape', 'wildlife'];\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        suggestions={suggestions}\n        showSuggestions={true}\n      />\n    );\n\n    const input = screen.getByRole('searchbox');\n    await user.type(input, 'n');\n\n    // Arrow down should highlight first suggestion\n    await user.keyboard('{ArrowDown}');\n    \n    const firstSuggestion = screen.getByText('nature');\n    expect(firstSuggestion).toHaveClass('highlighted');\n\n    // Arrow down again should highlight second suggestion\n    await user.keyboard('{ArrowDown}');\n    \n    const secondSuggestion = screen.getByText('landscape');\n    expect(secondSuggestion).toHaveClass('highlighted');\n\n    // Enter should select highlighted suggestion\n    await user.keyboard('{Enter}');\n    expect(mockOnSearch).toHaveBeenCalledWith('landscape');\n  });\n\n  it('should handle recent searches', () => {\n    const recentSearches = ['mountain', 'ocean', 'city'];\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        recentSearches={recentSearches}\n        showRecentSearches={true}\n      />\n    );\n\n    const input = screen.getByRole('searchbox');\n    fireEvent.focus(input);\n\n    recentSearches.forEach(search => {\n      expect(screen.getByText(search)).toBeInTheDocument();\n    });\n  });\n\n  it('should handle focus and blur events', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        onFocus={mockOnFocus}\n        onBlur={mockOnBlur}\n      />\n    );\n\n    const input = screen.getByRole('searchbox');\n    \n    await user.click(input);\n    expect(mockOnFocus).toHaveBeenCalled();\n    \n    await user.tab(); // Move focus away\n    expect(mockOnBlur).toHaveBeenCalled();\n  });\n\n  it('should be accessible with proper ARIA attributes', () => {\n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        ariaLabel=\"Search for images\"\n      />\n    );\n\n    const input = screen.getByRole('searchbox');\n    expect(input).toHaveAttribute('aria-label', 'Search for images');\n    \n    const form = input.closest('form');\n    expect(form).toHaveAttribute('role', 'search');\n  });\n\n  it('should support different sizes', () => {\n    const { rerender } = render(\n      <SearchBar onSearch={mockOnSearch} size=\"small\" />\n    );\n\n    let input = screen.getByRole('searchbox');\n    expect(input).toHaveClass('size-small');\n\n    rerender(<SearchBar onSearch={mockOnSearch} size=\"large\" />);\n    \n    input = screen.getByRole('searchbox');\n    expect(input).toHaveClass('size-large');\n  });\n\n  it('should handle voice search if available', async () => {\n    // Mock Speech Recognition API\n    const mockSpeechRecognition = {\n      start: vi.fn(),\n      stop: vi.fn(),\n      abort: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n    };\n\n    global.webkitSpeechRecognition = vi.fn(() => mockSpeechRecognition);\n    global.SpeechRecognition = vi.fn(() => mockSpeechRecognition);\n\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        enableVoiceSearch={true}\n      />\n    );\n\n    const voiceButton = screen.getByRole('button', { name: /voice search/i });\n    expect(voiceButton).toBeInTheDocument();\n    \n    await user.click(voiceButton);\n    expect(mockSpeechRecognition.start).toHaveBeenCalled();\n  });\n\n  it('should handle search history', () => {\n    const searchHistory = [\n      { query: 'nature', timestamp: Date.now() - 1000 },\n      { query: 'city', timestamp: Date.now() - 2000 },\n    ];\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        searchHistory={searchHistory}\n        showHistory={true}\n      />\n    );\n\n    const input = screen.getByRole('searchbox');\n    fireEvent.focus(input);\n\n    expect(screen.getByText('Recent Searches')).toBeInTheDocument();\n    expect(screen.getByText('nature')).toBeInTheDocument();\n    expect(screen.getByText('city')).toBeInTheDocument();\n  });\n\n  it('should validate input length', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        maxLength={10}\n        minLength={3}\n      />\n    );\n\n    const input = screen.getByRole('searchbox') as HTMLInputElement;\n    \n    // Test max length\n    await user.type(input, 'this is a very long search query');\n    expect(input.value.length).toBeLessThanOrEqual(10);\n    \n    // Test min length validation\n    await user.clear(input);\n    await user.type(input, 'ab');\n    \n    const searchButton = screen.getByRole('button', { name: /search/i });\n    await user.click(searchButton);\n    \n    expect(mockOnSearch).not.toHaveBeenCalled();\n    expect(screen.getByText(/minimum 3 characters/i)).toBeInTheDocument();\n  });\n\n  it('should debounce search suggestions', async () => {\n    const mockFetchSuggestions = vi.fn();\n    const user = userEvent.setup();\n    \n    render(\n      <SearchBar \n        onSearch={mockOnSearch}\n        onFetchSuggestions={mockFetchSuggestions}\n        debounceMs={300}\n      />\n    );\n\n    const input = screen.getByRole('searchbox');\n    \n    // Type quickly\n    await user.type(input, 'nature', { delay: 50 });\n    \n    // Should not call immediately\n    expect(mockFetchSuggestions).not.toHaveBeenCalled();\n    \n    // Wait for debounce\n    await waitFor(() => {\n      expect(mockFetchSuggestions).toHaveBeenCalledWith('nature');\n    }, { timeout: 400 });\n  });\n});"